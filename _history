{"entries":[{"timestamp":1753389506132,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":11578,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":118,"length1":126,"diffs":[[1,"        \"microphone\": \"*\"\n"]]},{"start1":235,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1753390056776,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":319,"length1":0,"diffs":[[1,"  https://github.com/elecfreaks/pxt-PlanetX/blob/master/display.ts\r\n- the ElecFreaks 'pxt-PlanetX-AI' library:\r\n  https://github.com/elecfreaks/pxt-PlanetX-AI/blob/master/main.ts\r\n"]]},{"start1":1807,"length1":49,"diffs":[[1,""]]}]}]},{"timestamp":1753390656121,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":319,"length1":25,"diffs":[[1,"All under MIT-license.\r\n"]]},{"start1":11333,"length1":61,"diffs":[[1,""]]},{"start1":11446,"length1":222,"diffs":[[1,""]]}]}]},{"timestamp":1753391241910,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11372,"length1":149,"diffs":[[1,"let ASSIGN = [\"\", \"\"]\r\n"]]},{"start1":11508,"length1":406,"diffs":[[1,""]]},{"start1":11730,"length1":224,"diffs":[[1,""]]}]}]},{"timestamp":1753391825528,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11722,"length1":79,"diffs":[[1,"    export function moveUp(dest: string, color: Color) {\r\n        Nezha.servoAngle(Nezha.S1,)\r\n"]]},{"start1":11914,"length1":81,"diffs":[[1,"    export function assign(dest: string, color: Color) {\r\n        let ix: number = color\r\n        ASSIGN[ix] = dest\r\n"]]},{"start1":12262,"length1":0,"diffs":[[1,"\r\n    //% block=\"assign %dest to box %color\"\r\n    //% block.loc.nl=\"wijs %dest toe aan vak %color\"\r\n    export function assign(dest: string, color: Color) {\r\n        let ix: number = color\r\n        ASSIGN[ix] = dest\r\n    }\r\n"]]}]}]},{"timestamp":1753392031658,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11523,"length1":2,"diffs":[[1,""]]}]}]},{"timestamp":1753435022032,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11523,"length1":4,"diffs":[[1,"\r\n"]]}]}]},{"timestamp":1753435022721,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":624,"length1":183,"diffs":[[1,""]]},{"start1":1376,"length1":0,"diffs":[[1,"    export enum Servo {\r\n        //% block=\"S1\" \r\n        S1,\r\n        //% block=\"S2\"\r\n        S2,\r\n        //% block=\"S3\" \r\n        S3,\r\n        //% block=\"S4\"\r\n        S4\r\n    }\r\n\r\n"]]},{"start1":11314,"length1":62,"diffs":[[1,"ColorSensor.init()\r\nlet HEADING = input.compassHeading()\r\n"]]},{"start1":11523,"length1":40,"diffs":[[1,"Ne\r\n"]]}]}]},{"timestamp":1753435619846,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11527,"length1":482,"diffs":[[1,"Nezha.servoAngle( Nezha.Servo.S2, 0)\r\n"]]}]}]},{"timestamp":1753436215928,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11582,"length1":274,"diffs":[[1,"    for (let i = 0; i < 15; i++) {\r\n        Nezha.servoAngle( Nezha.Servo.S2, 360 - i)\r\n        basic.pause(100)\r\n"]]},{"start1":11703,"length1":292,"diffs":[[1,"    for (let i = 0; i < 15; i++) {\r\n        Nezha.servoAngle( Nezha.Servo.S2, 360 - i)\r\n        basic.pause(100)\r\n"]]},{"start1":11824,"length1":0,"diffs":[[1,"    }\r\n"]]},{"start1":11834,"length1":0,"diffs":[[1,"basic.pause(500)\r\nNezha.servoAngle( Nezha.Servo.S1, 10)\r\nbasic.pause(2000)\r\nNezha.servoAngle( Nezha.Servo.S1, 360)\r\nbasic.pause(2000)\r\nNezha.servoAngle( Nezha.Servo.S2, 360)\r\n"]]},{"start1":12011,"length1":46,"diffs":[[1,""]]}]}]},{"timestamp":1753436701317,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11582,"length1":214,"diffs":[[1,"        for (let i = 340; i >= 0; i--) {\r\n            Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n            basic.pause(5)\r\n        }\r\n"]]},{"start1":11816,"length1":30,"diffs":[[1,"            basic.pause(10)\r\n"]]},{"start1":11978,"length1":30,"diffs":[[1,"            basic.pause(10)\r\n"]]},{"start1":12018,"length1":42,"diffs":[[1,"        for (let i = 0; i <= 340; i++) {\r\n"]]},{"start1":12116,"length1":28,"diffs":[[1,"            basic.pause(5)\r\n"]]},{"start1":12167,"length1":19,"diffs":[[1,""]]}]}]},{"timestamp":1753437297149,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11527,"length1":0,"diffs":[[1,"function lift(dir: boolean) {\r\n    if (dir) { // down\r\n            Nezha.servoAngle( Nezha.Servo.S1, 355)\r\n            basic.pause(2)\r\n            Nezha.servoAngle( Nezha.Servo.S1, 350)\r\n            basic.pause(2)\r\n            Nezha.servoAngle( Nezha.Servo.S1, 345)\r\n\r\n        for (let i = 15; i >= 0; i--) {\r\n            Nezha.servoAngle( Nezha.Servo.S2, 360 - i)\r\n            basic.pause(100)\r\n        }\r\n    }\r\n    else { // up\r\n        for (let i = 0; i <= 15; i++) {\r\n            Nezha.servoAngle( Nezha.Servo.S2, 360 - i)\r\n            basic.pause(100)\r\n        }\r\n        for (let i = 0; i <= 320; i++) {\r\n            Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n            basic.pause(2)\r\n        }\r\n    }\r\n}\r\n\r\nbasic.pause(3000)\r\nlift(false)\r\nbasic.pause(1000)\r\nlift(true)\r\n\r\n"]]},{"start1":12776,"length1":686,"diffs":[[1,""]]}]}]},{"timestamp":1753437893008,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11527,"length1":333,"diffs":[[1,""]]},{"start1":11638,"length1":171,"diffs":[[1,"    //% block=\"move the lift down\"\r\n    //% block.loc.nl=\"beweeg de vork naar onderen\"\r\n    export function moveUp() {\r\n        Nezha.servoAngle(Nezha.Servo.S1, 180)\r\n"]]},{"start1":11814,"length1":119,"diffs":[[1,"    //% block=\"move the lift down\"\r\n    //% block.loc.nl=\"beweeg de vork naar onderen\"\r\n    export function moveDown() {\r\n        Nezha.servoAngle(Nezha.Servo.S1, 180)\r\n    }\r\n\r\n    function lift(dir: boolean) {\r\n"]]},{"start1":12673,"length1":7,"diffs":[[1,"}\r\n"]]}]}]},{"timestamp":1753438484447,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11755,"length1":21,"diffs":[[1,""]]},{"start1":11790,"length1":18,"diffs":[[1,""]]}]}]},{"timestamp":1753438543925,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11527,"length1":2,"diffs":[[1,""]]}]}]},{"timestamp":1753442294983,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11527,"length1":10,"diffs":[[1,"\r\n"]]}]}]},{"timestamp":1753442296812,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11314,"length1":41,"diffs":[[1,"//ColorSensor.init()\r\n//let HEADING = input.compassHeading()\r\n"]]},{"start1":11527,"length1":0,"diffs":[[1,"function\r\nbasic.showLeds(`\r\n    . . . . .\r\n    . . . . .\r\n    . . # . .\r\n    . . . . .\r\n    . . . . .\r\n    `)\r\nbasic.pause(500)\r\nbasic.showIcon(IconNames.SmallSquare)\r\nbasic.pause(500)\r\nbasic.showIcon(IconNames.Square)\r\nbasic.pause(500)\r\nbasic.clearScreen()\r\nCForklift.lift(CForklift.Lift.Up)\r\nbasic.pause(500)\r\nCForklift.lift(CForklift.Lift.Down)\r\nbasic.showIcon(IconNames.Yes)\r\n\r\n"]]},{"start1":12200,"length1":617,"diffs":[[1,""]]}]}]},{"timestamp":1753442433013,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":348,"length1":3,"diffs":[[1,"\r\n"]]}]}]},{"timestamp":1753447674021,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":348,"length1":2,"diffs":[[1,"c\r\n"]]}]}]},{"timestamp":1753447675838,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12414,"length1":2,"diffs":[[1,""]]}]}]},{"timestamp":1753456647630,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12412,"length1":6,"diffs":[[1,""]]},{"start1":12414,"length1":0,"diffs":[[1,"\r\n"]]}]}]},{"timestamp":1753456648171,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12412,"length1":238,"diffs":[[1,"    \r\n"]]},{"start1":13416,"length1":86,"diffs":[[1,"}"]]}]}]},{"timestamp":1753457472685,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12518,"length1":60,"diffs":[[1,"        pins.setPull(Nezha.Connector.J1, PinPullMode.PullUp)\r\n"]]}]}]},{"timestamp":1753457478154,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12518,"length1":62,"diffs":[[1,"        pins.setPull(Nezha.Connector.J1, PinPullMode.Pull)\r\n"]]}]}]},{"timestamp":1753457682003,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12518,"length1":61,"diffs":[[1,"        pins.setPull(Nezha.Connector.J1, PinPullMode.PullUp)\r\n"]]}]}]},{"timestamp":1753464080602,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12518,"length1":60,"diffs":[[1,"        pins.setPull(Nezha.Connector.J, PinPullMode.PullUp)\r\n"]]}]}]},{"timestamp":1753464080625,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12518,"length1":62,"diffs":[[1,"        pins.setPull(Nezha.Connector., PinPullMode.PullUp)\r\n"]]},{"start1":13651,"length1":131,"diffs":[[1,"if (CForklift.isLoaded())\r\n    basic.showNumber(1)\r\nelse\r\n    basic.showNumber(0)"]]}]}]},{"timestamp":1753464615624,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":13651,"length1":0,"diffs":[[1,"\r\nbasic.forever(function() {\r\n    if (CForklift.isLoaded())\r\n        basic.showNumber(1)\r\n    else\r\n        basic.showNumber(0)\r\n})\r\n"]]}]}]},{"timestamp":1753464688346,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11506,"length1":4,"diffs":[[1,""]]}]}]},{"timestamp":1753466857866,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11506,"length1":7,"diffs":[[1,""]]},{"start1":11508,"length1":0,"diffs":[[1,"\r\n"]]}]}]},{"timestamp":1753466860901,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11506,"length1":248,"diffs":[[1,"enum \r\n"]]},{"start1":11515,"length1":294,"diffs":[[1,""]]},{"start1":13657,"length1":2333,"diffs":[[1,""]]}]}]},{"timestamp":1753467432435,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":11538,"length1":2,"diffs":[[1,""]]},{"start1":13018,"length1":43,"diffs":[[1,"    export function isLoaded() : boolean {\r\n"]]},{"start1":13196,"length1":231,"diffs":[[1,""]]},{"start1":14248,"length1":202,"diffs":[[1,"    //% block=\"bring to green\"\r\n    //% block.locx.nl=\"breng naar groen\"\r\n    export function goRouteGreenBring(programmableCode: () => void): void {\r\n        RouteGreenBring = programmableCode;\r\n"]]},{"start1":14507,"length1":202,"diffs":[[1,"    //% block=\"back from start\"\r\n    //% block.locx.nl=\"terug van groen\"\r\n    export function goRouteGreenStart(programmableCode: () => void): void {\r\n        RouteGreenBring = programmableCode;\r\n"]]},{"start1":14766,"length1":199,"diffs":[[1,"    //% block=\"bring to green\"\r\n    //% block.locx.nl=\"breng naar groen\"\r\n    export function goRouteGreenBring(programmableCode: () => void): void {\r\n        RouteGreenBring = programmableCode;\r\n"]]},{"start1":15025,"length1":199,"diffs":[[1,"    //% block=\"bring to green\"\r\n    //% block.locx.nl=\"breng naar groen\"\r\n    export function goRouteGreenBring(programmableCode: () => void): void {\r\n        RouteGreenBring = programmableCode;\r\n"]]},{"start1":15284,"length1":203,"diffs":[[1,"    //% block=\"bring to green\"\r\n    //% block.locx.nl=\"breng naar groen\"\r\n    export function goRouteGreenBring(programmableCode: () => void): void {\r\n        RouteGreenBring = programmableCode;\r\n"]]},{"start1":15543,"length1":204,"diffs":[[1,"    //% block=\"bring to green\"\r\n    //% block.locx.nl=\"breng naar groen\"\r\n    export function goRouteGreenBring(programmableCode: () => void): void {\r\n        RouteGreenBring = programmableCode;\r\n"]]},{"start1":15802,"length1":211,"diffs":[[1,"    //% block=\"bring to green\"\r\n    //% block.locx.nl=\"breng naar groen\"\r\n    export function goRouteGreenBring(programmableCode: () => void): void {\r\n        RouteGreenBring = programmableCode;\r\n"]]},{"start1":16061,"length1":206,"diffs":[[1,"    //% block=\"bring to green\"\r\n    //% block.locx.nl=\"breng naar groen\"\r\n    export function goRouteGreenBring(programmableCode: () => void): void {\r\n        RouteGreenBring = programmableCode;\r\n"]]},{"start1":16264,"length1":0,"diffs":[[1,"\r\n    //% subcategory=\"Route\"\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"bring to green\"\r\n    //% block.locx.nl=\"breng naar groen\"\r\n    export function goRouteGreenBring(programmableCode: () => void): void {\r\n        RouteGreenBring = programmableCode;\r\n    }\r\n\r\n"]]}]}]},{"timestamp":1753468032363,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12343,"length1":569,"diffs":[[1,""]]},{"start1":12958,"length1":287,"diffs":[[1,""]]},{"start1":13197,"length1":93,"diffs":[[1,"    //% block=\"load\"\r\n    //% block.loc.nl=\"inladen\"\r\n    export function isLoaded(): boolean {\r\n        pins.setPull(Nezha.Connector.J1, PinPullMode.PullUp)\r\n        return (pins.digitalReadPin(Nezha.Connector.J1) == 0)\r\n"]]},{"start1":13428,"length1":97,"diffs":[[1,""]]}]}]},{"timestamp":1753468630739,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":12727,"length1":215,"diffs":[[1,"        //% block=\"to the left\"\r\n        //% block.loc.nl=\"naar links\"\r\n"]]},{"start1":12814,"length1":62,"diffs":[[1,"        //% block=\"to the right\"\r\n        //% block.loc.nl=\"naar rechts\"\r\n"]]},{"start1":12912,"length1":261,"diffs":[[1,""]]},{"start1":13527,"length1":309,"diffs":[[1,"    \r\n"]]},{"start1":13535,"length1":320,"diffs":[[1,""]]},{"start1":15026,"length1":0,"diffs":[[1,"    //% block=\"assign %dest to box %color\"\r\n    //% block.loc.nl=\"wijs %dest toe aan vak %color\"\r\n    export function assign(dest: string, color: Color) {\r\n        let ix: number = color\r\n        ASSIGN[ix] = dest\r\n    }\r\n\r\n"]]}]}]},{"timestamp":1753469178586,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":335,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests gaan hier; deze zal niet worden gecompileerd wanneer dit pakket wordt gebruikt als extensie.\n"}]}],"snapshots":[{"timestamp":1753389506131,"editorVersion":"8.0.11","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-forklift\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1753391316785,"editorVersion":"8.0.11","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nFrom here to the 'pxt-soccer-player' specific code,\r\nthe code below is a composition and refactoring of:\r\n- the ElecFreaks 'pxt-nezha' library:\r\n  https://github.com/elecfreaks/pxt-nezha/blob/master/main.ts\r\n- the ElecFreaks 'pxt-PlanetX' library:\r\n  https://github.com/elecfreaks/pxt-PlanetX/blob/master/basic.ts\r\nBoth under MIT-license.\r\n*/\r\n\r\nnamespace Nezha {\r\n\r\n    export enum Connector {\r\n        //% block=\"J1\" \r\n        J1 = DigitalPin.P8,\r\n        //% block=\"J2\"\r\n        J2 = DigitalPin.P12,\r\n        //% block=\"J3\"\r\n        J3 = DigitalPin.P14,\r\n        //% block=\"J4\"\r\n        J4 = DigitalPin.P16\r\n    }\r\n\r\n    export enum Motor {\r\n        //% block=\"M1\"\r\n        M1,\r\n        //% block=\"M2\"\r\n        M2,\r\n        //% block=\"M3\"\r\n        M3,\r\n        //% block=\"M4\"\r\n        M4\r\n    }\r\n\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 100) speed = 100\r\n        else\r\n            if (speed < -100) speed = -100\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export enum Servo {\r\n        //% block=\"S1\" \r\n        S1,\r\n        //% block=\"S2\"\r\n        S2,\r\n        //% block=\"S3\" \r\n        S3,\r\n        //% block=\"S4\"\r\n        S4\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, 360, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n}\r\n\r\n/*\r\nGeneral color module\r\nUsed by ColorSensor\r\n*/\r\n\r\nenum Color {\r\n    //% block=\"none\"\r\n    //% block.loc.nl=\"geen\"\r\n    None,\r\n    //% block=\"green\"\r\n    //% block.loc.nl=\"groen\"\r\n    Green,\r\n    //% block=\"blue\"\r\n    //% block.loc.nl=\"blauw\"\r\n    Blue,\r\n    //% block=\"yellow\"\r\n    //% block.loc.nl=\"geel\"\r\n    Yellow,\r\n    //% block=\"black\"\r\n    //% block.loc.nl=\"zwart\"\r\n    Black,\r\n    //% block=\"red\"\r\n    //% block.loc.nl=\"rood\"\r\n    Red,\r\n    //% block=\"white\"\r\n    //% block.loc.nl=\"wit\"\r\n    White,\r\n    //% block=\"orange\"\r\n    //% block.loc.nl=\"oranje\"\r\n    Orange,\r\n    //% block=\"cyan\"\r\n    //% block.loc.nl=\"cyaan\"\r\n    Cyan,\r\n    //% block=\"magenta\"\r\n    //% block.loc.nl=\"magenta\"\r\n    Magenta,\r\n    //% block=\"indigo\"\r\n    //% block.loc.nl=\"indigo\"\r\n    Indigo,\r\n    //% block=\"violet\"\r\n    //% block.loc.nl=\"violet\"\r\n    Violet,\r\n    //% block=\"purple\"\r\n    //% block.loc.nl=\"paars\"\r\n    Purple\r\n}\r\n\r\nfunction rgb(color: Color): number {\r\n    let val = 0\r\n    switch (color) {\r\n        case Color.Green: val = 0x00FF00; break;\r\n        case Color.Blue: val = 0x0000FF; break;\r\n        case Color.Yellow: val = 0xFFFF00; break;\r\n        case Color.Black: val = 0x000000; break;\r\n        case Color.Red: val = 0xFF0000; break;\r\n        case Color.White: val = 0xFFFFFF; break;\r\n        case Color.Orange: val = 0xFFA500; break;\r\n        case Color.Cyan: val = 0x00FFFF; break;\r\n        case Color.Magenta: val = 0xFF00FF; break;\r\n        case Color.Indigo: val = 0x4b0082; break;\r\n        case Color.Violet: val = 0x8a2be2; break;\r\n        case Color.Purple: val = 0xFF00FF; break;\r\n    }\r\n    return val\r\n}\r\n\r\nfunction pack(red: number, green: number, blue: number): number {\r\n    let rgb = ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF)\r\n    return rgb;\r\n}\r\n\r\nfunction rgb2hsl(color_r: number, color_g: number, color_b: number): number {\r\n    let Hue = 0\r\n    let R = color_r * 100 / 255;\r\n    let G = color_g * 100 / 255;\r\n    let B = color_b * 100 / 255;\r\n    let maxVal = Math.max(R, Math.max(G, B))\r\n    let minVal = Math.min(R, Math.min(G, B))\r\n    let Delta = maxVal - minVal;\r\n\r\n    if (Delta < 0) {\r\n        Hue = 0;\r\n    }\r\n    else if (maxVal == R && G >= B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta)) / 100;\r\n    }\r\n    else if (maxVal == R && G < B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta) + 360 * 100) / 100;\r\n    }\r\n    else if (maxVal == G) {\r\n        Hue = (60 * ((B - R) * 100 / Delta) + 120 * 100) / 100;\r\n    }\r\n    else if (maxVal == B) {\r\n        Hue = (60 * ((R - G) * 100 / Delta) + 240 * 100) / 100;\r\n    }\r\n    return Hue\r\n}\r\n\r\nfunction hsl2rgb(h: number, s: number, l: number): number {\r\n    h = Math.round(h);\r\n    s = Math.round(s);\r\n    l = Math.round(l);\r\n\r\n    h = h % 360;\r\n    s = Math.clamp(0, 99, s);\r\n    l = Math.clamp(0, 99, l);\r\n    let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\r\n    let h1 = Math.idiv(h, 60);//[0,6]\r\n    let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\r\n    let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\r\n    let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\r\n    let r$: number;\r\n    let g$: number;\r\n    let b$: number;\r\n    if (h1 == 0) {\r\n        r$ = c;\r\n        g$ = x;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 1) {\r\n        r$ = x;\r\n        g$ = c;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 2) {\r\n        r$ = 0;\r\n        g$ = c;\r\n        b$ = x;\r\n    }\r\n    else if (h1 == 3) {\r\n        r$ = 0;\r\n        g$ = x;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 4) {\r\n        r$ = x;\r\n        g$ = 0;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 5) {\r\n        r$ = c;\r\n        g$ = 0;\r\n        b$ = x;\r\n    }\r\n    let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\r\n    let r = r$ + m;\r\n    let g = g$ + m;\r\n    let b = b$ + m;\r\n    let rgb = ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF)\r\n    return rgb;\r\n}\r\n\r\n/*\r\nPlanetX color sensor\r\n*/\r\n\r\nnamespace ColorSensor {\r\n\r\n    const APDS9960_ADDR = 0x39\r\n    const APDS9960_ENABLE = 0x80\r\n    const APDS9960_ATIME = 0x81\r\n    const APDS9960_CONTROL = 0x8F\r\n    const APDS9960_STATUS = 0x93\r\n    const APDS9960_CDATAL = 0x94\r\n    const APDS9960_CDATAH = 0x95\r\n    const APDS9960_RDATAL = 0x96\r\n    const APDS9960_RDATAH = 0x97\r\n    const APDS9960_GDATAL = 0x98\r\n    const APDS9960_GDATAH = 0x99\r\n    const APDS9960_BDATAL = 0x9A\r\n    const APDS9960_BDATAH = 0x9B\r\n    const APDS9960_GCONF4 = 0xAB\r\n    const APDS9960_AICLEAR = 0xE7\r\n\r\n    let color_first_init = false\r\n    let color_new_init = false\r\n\r\n    function i2cwrite_color(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread_color(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    export function init() {\r\n\r\n        // init module\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ATIME, 252)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_CONTROL, 0x03)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_GCONF4, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_AICLEAR, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x01)\r\n        color_first_init = true\r\n\r\n        // set to color mode\r\n        let tmp = i2cread_color(APDS9960_ADDR, APDS9960_ENABLE) | 0x2;\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, tmp);\r\n    }\r\n\r\n    export function readColor(): Color {\r\n        let buf = pins.createBuffer(2)\r\n        let c = 0\r\n        let r = 0\r\n        let g = 0\r\n        let b = 0\r\n        let temp_c = 0\r\n        let temp_r = 0\r\n        let temp_g = 0\r\n        let temp_b = 0\r\n        let temp = 0\r\n\r\n        if (color_new_init == false && color_first_init == false) {\r\n            let i = 0;\r\n            while (i++ < 20) {\r\n                buf[0] = 0x81\r\n                buf[1] = 0xCA\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                buf[0] = 0x80\r\n                buf[1] = 0x17\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                basic.pause(50);\r\n\r\n                if ((i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256) != 0) {\r\n                    color_new_init = true\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (color_new_init == true) {\r\n            basic.pause(100);\r\n            c = i2cread_color(0x43, 0xA6) + i2cread_color(0x43, 0xA7) * 256;\r\n            r = i2cread_color(0x43, 0xA0) + i2cread_color(0x43, 0xA1) * 256;\r\n            g = i2cread_color(0x43, 0xA2) + i2cread_color(0x43, 0xA3) * 256;\r\n            b = i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256;\r\n\r\n            r *= 1.3 * 0.47 * 0.83\r\n            g *= 0.69 * 0.56 * 0.83\r\n            b *= 0.80 * 0.415 * 0.83\r\n            c *= 0.3\r\n\r\n            if (r > b && r > g) {\r\n                b *= 1.18;\r\n                g *= 0.95\r\n            }\r\n\r\n            temp_c = c\r\n            temp_r = r\r\n            temp_g = g\r\n            temp_b = b\r\n\r\n            r = Math.min(r, 4095.9356)\r\n            g = Math.min(g, 4095.9356)\r\n            b = Math.min(b, 4095.9356)\r\n            c = Math.min(c, 4095.9356)\r\n\r\n            if (temp_b < temp_g) {\r\n                temp = temp_b\r\n                temp_b = temp_g\r\n                temp_g = temp\r\n            }\r\n        }\r\n        else {\r\n            if (color_first_init == false)\r\n                init()\r\n            let tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            while (!tmp) {\r\n                basic.pause(5);\r\n                tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            }\r\n            c = i2cread_color(APDS9960_ADDR, APDS9960_CDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_CDATAH) * 256;\r\n            r = i2cread_color(APDS9960_ADDR, APDS9960_RDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_RDATAH) * 256;\r\n            g = i2cread_color(APDS9960_ADDR, APDS9960_GDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_GDATAH) * 256;\r\n            b = i2cread_color(APDS9960_ADDR, APDS9960_BDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_BDATAH) * 256;\r\n        }\r\n\r\n        // map to rgb based on clear channel\r\n        let avg = c / 3;\r\n        r = r * 255 / avg;\r\n        g = g * 255 / avg;\r\n        b = b * 255 / avg;\r\n\r\n        // translate rgb to hue\r\n        let hue = rgb2hsl(r, g, b)\r\n        if (color_new_init == true && hue >= 180 && hue <= 201 && temp_c >= 6000 && (temp_b - temp_g) < 1000 || (temp_r > 4096 && temp_g > 4096 && temp_b > 4096)) {\r\n            temp_c = Math.map(temp_c, 0, 15000, 0, 13000);\r\n            hue = 180 + (13000 - temp_c) / 1000.0;\r\n        }\r\n\r\n        // translate hue to color\r\n        if (hue > 330 || hue < 20)\r\n            return Color.Red\r\n        if (hue > 120 && 180 > hue)\r\n            return Color.Green\r\n        if (hue > 210 && 270 > hue)\r\n            return Color.Blue\r\n        if (hue > 190 && 210 > hue)\r\n            return Color.Cyan\r\n        if (hue > 260 && 330 > hue)\r\n            return Color.Magenta\r\n        if (hue > 30 && 120 > hue)\r\n            return Color.Yellow\r\n        if (hue >= 180 && 190 > hue)\r\n            return Color.White\r\n        return Color.Black\r\n    }\r\n\r\n}\r\n\r\nColorSensor.init()\r\nlet HEADING = input.compassHeading()\r\nlet ASSIGN = [\"kiwi\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Forklift\"\r\n//% block.loc.nl=\"Heftruck\"\r\nnamespace CForklift {\r\n\r\n    //% block=\"assign %dest to box %color\"\r\n    //% block.loc.nl=\"wijs %dest toe aan vak %color\"\r\n    export function assign(dest: string, color: Color) {\r\n        let ix: number = color\r\n        ASSIGN[ix] = dest\r\n    }\r\n}","README.md":"","pxt.json":"{\n    \"name\": \"pxt-forklift\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-mecanum\": \"github:CBurg-College/pxt-mecanum#fde56d8c97bd92d2e7600e8cdf3c245f626b405e\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1753435022032,"editorVersion":"8.0.11","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nFrom here to the 'pxt-soccer-player' specific code,\r\nthe code below is a composition and refactoring of:\r\n- the ElecFreaks 'pxt-nezha' library:\r\n  https://github.com/elecfreaks/pxt-nezha/blob/master/main.ts\r\n- the ElecFreaks 'pxt-PlanetX' library:\r\n  https://github.com/elecfreaks/pxt-PlanetX/blob/master/basic.ts\r\nBoth under MIT-license.\r\n*/\r\n\r\nnamespace Nezha {\r\n\r\n    export enum Connector {\r\n        //% block=\"J1\" \r\n        J1 = DigitalPin.P8,\r\n        //% block=\"J2\"\r\n        J2 = DigitalPin.P12,\r\n        //% block=\"J3\"\r\n        J3 = DigitalPin.P14,\r\n        //% block=\"J4\"\r\n        J4 = DigitalPin.P16\r\n    }\r\n\r\n    export enum Motor {\r\n        //% block=\"M1\"\r\n        M1,\r\n        //% block=\"M2\"\r\n        M2,\r\n        //% block=\"M3\"\r\n        M3,\r\n        //% block=\"M4\"\r\n        M4\r\n    }\r\n\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 100) speed = 100\r\n        else\r\n            if (speed < -100) speed = -100\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export enum Servo {\r\n        //% block=\"S1\" \r\n        S1,\r\n        //% block=\"S2\"\r\n        S2,\r\n        //% block=\"S3\" \r\n        S3,\r\n        //% block=\"S4\"\r\n        S4\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, 360, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n}\r\n\r\n/*\r\nGeneral color module\r\nUsed by ColorSensor\r\n*/\r\n\r\nenum Color {\r\n    //% block=\"none\"\r\n    //% block.loc.nl=\"geen\"\r\n    None,\r\n    //% block=\"green\"\r\n    //% block.loc.nl=\"groen\"\r\n    Green,\r\n    //% block=\"blue\"\r\n    //% block.loc.nl=\"blauw\"\r\n    Blue,\r\n    //% block=\"yellow\"\r\n    //% block.loc.nl=\"geel\"\r\n    Yellow,\r\n    //% block=\"black\"\r\n    //% block.loc.nl=\"zwart\"\r\n    Black,\r\n    //% block=\"red\"\r\n    //% block.loc.nl=\"rood\"\r\n    Red,\r\n    //% block=\"white\"\r\n    //% block.loc.nl=\"wit\"\r\n    White,\r\n    //% block=\"orange\"\r\n    //% block.loc.nl=\"oranje\"\r\n    Orange,\r\n    //% block=\"cyan\"\r\n    //% block.loc.nl=\"cyaan\"\r\n    Cyan,\r\n    //% block=\"magenta\"\r\n    //% block.loc.nl=\"magenta\"\r\n    Magenta,\r\n    //% block=\"indigo\"\r\n    //% block.loc.nl=\"indigo\"\r\n    Indigo,\r\n    //% block=\"violet\"\r\n    //% block.loc.nl=\"violet\"\r\n    Violet,\r\n    //% block=\"purple\"\r\n    //% block.loc.nl=\"paars\"\r\n    Purple\r\n}\r\n\r\nfunction rgb(color: Color): number {\r\n    let val = 0\r\n    switch (color) {\r\n        case Color.Green: val = 0x00FF00; break;\r\n        case Color.Blue: val = 0x0000FF; break;\r\n        case Color.Yellow: val = 0xFFFF00; break;\r\n        case Color.Black: val = 0x000000; break;\r\n        case Color.Red: val = 0xFF0000; break;\r\n        case Color.White: val = 0xFFFFFF; break;\r\n        case Color.Orange: val = 0xFFA500; break;\r\n        case Color.Cyan: val = 0x00FFFF; break;\r\n        case Color.Magenta: val = 0xFF00FF; break;\r\n        case Color.Indigo: val = 0x4b0082; break;\r\n        case Color.Violet: val = 0x8a2be2; break;\r\n        case Color.Purple: val = 0xFF00FF; break;\r\n    }\r\n    return val\r\n}\r\n\r\nfunction pack(red: number, green: number, blue: number): number {\r\n    let rgb = ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF)\r\n    return rgb;\r\n}\r\n\r\nfunction rgb2hsl(color_r: number, color_g: number, color_b: number): number {\r\n    let Hue = 0\r\n    let R = color_r * 100 / 255;\r\n    let G = color_g * 100 / 255;\r\n    let B = color_b * 100 / 255;\r\n    let maxVal = Math.max(R, Math.max(G, B))\r\n    let minVal = Math.min(R, Math.min(G, B))\r\n    let Delta = maxVal - minVal;\r\n\r\n    if (Delta < 0) {\r\n        Hue = 0;\r\n    }\r\n    else if (maxVal == R && G >= B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta)) / 100;\r\n    }\r\n    else if (maxVal == R && G < B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta) + 360 * 100) / 100;\r\n    }\r\n    else if (maxVal == G) {\r\n        Hue = (60 * ((B - R) * 100 / Delta) + 120 * 100) / 100;\r\n    }\r\n    else if (maxVal == B) {\r\n        Hue = (60 * ((R - G) * 100 / Delta) + 240 * 100) / 100;\r\n    }\r\n    return Hue\r\n}\r\n\r\nfunction hsl2rgb(h: number, s: number, l: number): number {\r\n    h = Math.round(h);\r\n    s = Math.round(s);\r\n    l = Math.round(l);\r\n\r\n    h = h % 360;\r\n    s = Math.clamp(0, 99, s);\r\n    l = Math.clamp(0, 99, l);\r\n    let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\r\n    let h1 = Math.idiv(h, 60);//[0,6]\r\n    let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\r\n    let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\r\n    let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\r\n    let r$: number;\r\n    let g$: number;\r\n    let b$: number;\r\n    if (h1 == 0) {\r\n        r$ = c;\r\n        g$ = x;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 1) {\r\n        r$ = x;\r\n        g$ = c;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 2) {\r\n        r$ = 0;\r\n        g$ = c;\r\n        b$ = x;\r\n    }\r\n    else if (h1 == 3) {\r\n        r$ = 0;\r\n        g$ = x;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 4) {\r\n        r$ = x;\r\n        g$ = 0;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 5) {\r\n        r$ = c;\r\n        g$ = 0;\r\n        b$ = x;\r\n    }\r\n    let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\r\n    let r = r$ + m;\r\n    let g = g$ + m;\r\n    let b = b$ + m;\r\n    let rgb = ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF)\r\n    return rgb;\r\n}\r\n\r\n/*\r\nPlanetX color sensor\r\n*/\r\n\r\nnamespace ColorSensor {\r\n\r\n    const APDS9960_ADDR = 0x39\r\n    const APDS9960_ENABLE = 0x80\r\n    const APDS9960_ATIME = 0x81\r\n    const APDS9960_CONTROL = 0x8F\r\n    const APDS9960_STATUS = 0x93\r\n    const APDS9960_CDATAL = 0x94\r\n    const APDS9960_CDATAH = 0x95\r\n    const APDS9960_RDATAL = 0x96\r\n    const APDS9960_RDATAH = 0x97\r\n    const APDS9960_GDATAL = 0x98\r\n    const APDS9960_GDATAH = 0x99\r\n    const APDS9960_BDATAL = 0x9A\r\n    const APDS9960_BDATAH = 0x9B\r\n    const APDS9960_GCONF4 = 0xAB\r\n    const APDS9960_AICLEAR = 0xE7\r\n\r\n    let color_first_init = false\r\n    let color_new_init = false\r\n\r\n    function i2cwrite_color(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread_color(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    export function init() {\r\n\r\n        // init module\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ATIME, 252)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_CONTROL, 0x03)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_GCONF4, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_AICLEAR, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x01)\r\n        color_first_init = true\r\n\r\n        // set to color mode\r\n        let tmp = i2cread_color(APDS9960_ADDR, APDS9960_ENABLE) | 0x2;\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, tmp);\r\n    }\r\n\r\n    export function readColor(): Color {\r\n        let buf = pins.createBuffer(2)\r\n        let c = 0\r\n        let r = 0\r\n        let g = 0\r\n        let b = 0\r\n        let temp_c = 0\r\n        let temp_r = 0\r\n        let temp_g = 0\r\n        let temp_b = 0\r\n        let temp = 0\r\n\r\n        if (color_new_init == false && color_first_init == false) {\r\n            let i = 0;\r\n            while (i++ < 20) {\r\n                buf[0] = 0x81\r\n                buf[1] = 0xCA\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                buf[0] = 0x80\r\n                buf[1] = 0x17\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                basic.pause(50);\r\n\r\n                if ((i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256) != 0) {\r\n                    color_new_init = true\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (color_new_init == true) {\r\n            basic.pause(100);\r\n            c = i2cread_color(0x43, 0xA6) + i2cread_color(0x43, 0xA7) * 256;\r\n            r = i2cread_color(0x43, 0xA0) + i2cread_color(0x43, 0xA1) * 256;\r\n            g = i2cread_color(0x43, 0xA2) + i2cread_color(0x43, 0xA3) * 256;\r\n            b = i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256;\r\n\r\n            r *= 1.3 * 0.47 * 0.83\r\n            g *= 0.69 * 0.56 * 0.83\r\n            b *= 0.80 * 0.415 * 0.83\r\n            c *= 0.3\r\n\r\n            if (r > b && r > g) {\r\n                b *= 1.18;\r\n                g *= 0.95\r\n            }\r\n\r\n            temp_c = c\r\n            temp_r = r\r\n            temp_g = g\r\n            temp_b = b\r\n\r\n            r = Math.min(r, 4095.9356)\r\n            g = Math.min(g, 4095.9356)\r\n            b = Math.min(b, 4095.9356)\r\n            c = Math.min(c, 4095.9356)\r\n\r\n            if (temp_b < temp_g) {\r\n                temp = temp_b\r\n                temp_b = temp_g\r\n                temp_g = temp\r\n            }\r\n        }\r\n        else {\r\n            if (color_first_init == false)\r\n                init()\r\n            let tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            while (!tmp) {\r\n                basic.pause(5);\r\n                tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            }\r\n            c = i2cread_color(APDS9960_ADDR, APDS9960_CDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_CDATAH) * 256;\r\n            r = i2cread_color(APDS9960_ADDR, APDS9960_RDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_RDATAH) * 256;\r\n            g = i2cread_color(APDS9960_ADDR, APDS9960_GDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_GDATAH) * 256;\r\n            b = i2cread_color(APDS9960_ADDR, APDS9960_BDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_BDATAH) * 256;\r\n        }\r\n\r\n        // map to rgb based on clear channel\r\n        let avg = c / 3;\r\n        r = r * 255 / avg;\r\n        g = g * 255 / avg;\r\n        b = b * 255 / avg;\r\n\r\n        // translate rgb to hue\r\n        let hue = rgb2hsl(r, g, b)\r\n        if (color_new_init == true && hue >= 180 && hue <= 201 && temp_c >= 6000 && (temp_b - temp_g) < 1000 || (temp_r > 4096 && temp_g > 4096 && temp_b > 4096)) {\r\n            temp_c = Math.map(temp_c, 0, 15000, 0, 13000);\r\n            hue = 180 + (13000 - temp_c) / 1000.0;\r\n        }\r\n\r\n        // translate hue to color\r\n        if (hue > 330 || hue < 20)\r\n            return Color.Red\r\n        if (hue > 120 && 180 > hue)\r\n            return Color.Green\r\n        if (hue > 210 && 270 > hue)\r\n            return Color.Blue\r\n        if (hue > 190 && 210 > hue)\r\n            return Color.Cyan\r\n        if (hue > 260 && 330 > hue)\r\n            return Color.Magenta\r\n        if (hue > 30 && 120 > hue)\r\n            return Color.Yellow\r\n        if (hue >= 180 && 190 > hue)\r\n            return Color.White\r\n        return Color.Black\r\n    }\r\n\r\n}\r\n\r\nColorSensor.init()\r\nlet HEADING = input.compassHeading()\r\nlet ASSIGN = [\"none\", \"groen\", \"blauw\", \"geel\", \"zwart\", \"rood\", \"wit\",\r\n                \"oranje\", \"cyaan\", \"magenta\", \"indigo\", \"violet\", \"paars\"]\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Forklift\"\r\n//% block.loc.nl=\"Heftruck\"\r\nnamespace CForklift {\r\n\r\n    //% block=\"move the lift down\"\r\n    //% block.loc.nl=\"beweeg de vork naar onderen\"\r\n    export function moveUp() {\r\n        Nezha.servoAngle(Nezha.Servo.S1, 180)\r\n    }\r\n\r\n    //% block=\"move the lift down\"\r\n    //% block.loc.nl=\"beweeg de vork naar onderen\"\r\n    export function moveDown() {\r\n        Nezha.servoAngle(Nezha.Servo.S1, 180)\r\n    }\r\n\r\n    //% block=\"assign %dest to box %color\"\r\n    //% block.loc.nl=\"wijs %dest toe aan vak %color\"\r\n    export function assign(dest: string, color: Color) {\r\n        let ix: number = color\r\n        ASSIGN[ix] = dest\r\n    }\r\n}","README.md":"","pxt.json":"{\n    \"name\": \"pxt-forklift\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-mecanum\": \"github:CBurg-College/pxt-mecanum#fde56d8c97bd92d2e7600e8cdf3c245f626b405e\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1753436823392,"editorVersion":"8.0.11","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nFrom here to the 'pxt-soccer-player' specific code,\r\nthe code below is a composition and refactoring of:\r\n- the ElecFreaks 'pxt-nezha' library:\r\n  https://github.com/elecfreaks/pxt-nezha/blob/master/main.ts\r\n- the ElecFreaks 'pxt-PlanetX' library:\r\n  https://github.com/elecfreaks/pxt-PlanetX/blob/master/basic.ts\r\nBoth under MIT-license.\r\n*/\r\n\r\nnamespace Nezha {\r\n\r\n    export enum Connector {\r\n        //% block=\"J1\" \r\n        J1 = DigitalPin.P8,\r\n        //% block=\"J2\"\r\n        J2 = DigitalPin.P12,\r\n        //% block=\"J3\"\r\n        J3 = DigitalPin.P14,\r\n        //% block=\"J4\"\r\n        J4 = DigitalPin.P16\r\n    }\r\n\r\n    export enum Servo {\r\n        //% block=\"S1\" \r\n        S1,\r\n        //% block=\"S2\"\r\n        S2,\r\n        //% block=\"S3\" \r\n        S3,\r\n        //% block=\"S4\"\r\n        S4\r\n    }\r\n\r\n    export enum Motor {\r\n        //% block=\"M1\"\r\n        M1,\r\n        //% block=\"M2\"\r\n        M2,\r\n        //% block=\"M3\"\r\n        M3,\r\n        //% block=\"M4\"\r\n        M4\r\n    }\r\n\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 100) speed = 100\r\n        else\r\n            if (speed < -100) speed = -100\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, 360, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n}\r\n\r\n/*\r\nGeneral color module\r\nUsed by ColorSensor\r\n*/\r\n\r\nenum Color {\r\n    //% block=\"none\"\r\n    //% block.loc.nl=\"geen\"\r\n    None,\r\n    //% block=\"green\"\r\n    //% block.loc.nl=\"groen\"\r\n    Green,\r\n    //% block=\"blue\"\r\n    //% block.loc.nl=\"blauw\"\r\n    Blue,\r\n    //% block=\"yellow\"\r\n    //% block.loc.nl=\"geel\"\r\n    Yellow,\r\n    //% block=\"black\"\r\n    //% block.loc.nl=\"zwart\"\r\n    Black,\r\n    //% block=\"red\"\r\n    //% block.loc.nl=\"rood\"\r\n    Red,\r\n    //% block=\"white\"\r\n    //% block.loc.nl=\"wit\"\r\n    White,\r\n    //% block=\"orange\"\r\n    //% block.loc.nl=\"oranje\"\r\n    Orange,\r\n    //% block=\"cyan\"\r\n    //% block.loc.nl=\"cyaan\"\r\n    Cyan,\r\n    //% block=\"magenta\"\r\n    //% block.loc.nl=\"magenta\"\r\n    Magenta,\r\n    //% block=\"indigo\"\r\n    //% block.loc.nl=\"indigo\"\r\n    Indigo,\r\n    //% block=\"violet\"\r\n    //% block.loc.nl=\"violet\"\r\n    Violet,\r\n    //% block=\"purple\"\r\n    //% block.loc.nl=\"paars\"\r\n    Purple\r\n}\r\n\r\nfunction rgb(color: Color): number {\r\n    let val = 0\r\n    switch (color) {\r\n        case Color.Green: val = 0x00FF00; break;\r\n        case Color.Blue: val = 0x0000FF; break;\r\n        case Color.Yellow: val = 0xFFFF00; break;\r\n        case Color.Black: val = 0x000000; break;\r\n        case Color.Red: val = 0xFF0000; break;\r\n        case Color.White: val = 0xFFFFFF; break;\r\n        case Color.Orange: val = 0xFFA500; break;\r\n        case Color.Cyan: val = 0x00FFFF; break;\r\n        case Color.Magenta: val = 0xFF00FF; break;\r\n        case Color.Indigo: val = 0x4b0082; break;\r\n        case Color.Violet: val = 0x8a2be2; break;\r\n        case Color.Purple: val = 0xFF00FF; break;\r\n    }\r\n    return val\r\n}\r\n\r\nfunction pack(red: number, green: number, blue: number): number {\r\n    let rgb = ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF)\r\n    return rgb;\r\n}\r\n\r\nfunction rgb2hsl(color_r: number, color_g: number, color_b: number): number {\r\n    let Hue = 0\r\n    let R = color_r * 100 / 255;\r\n    let G = color_g * 100 / 255;\r\n    let B = color_b * 100 / 255;\r\n    let maxVal = Math.max(R, Math.max(G, B))\r\n    let minVal = Math.min(R, Math.min(G, B))\r\n    let Delta = maxVal - minVal;\r\n\r\n    if (Delta < 0) {\r\n        Hue = 0;\r\n    }\r\n    else if (maxVal == R && G >= B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta)) / 100;\r\n    }\r\n    else if (maxVal == R && G < B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta) + 360 * 100) / 100;\r\n    }\r\n    else if (maxVal == G) {\r\n        Hue = (60 * ((B - R) * 100 / Delta) + 120 * 100) / 100;\r\n    }\r\n    else if (maxVal == B) {\r\n        Hue = (60 * ((R - G) * 100 / Delta) + 240 * 100) / 100;\r\n    }\r\n    return Hue\r\n}\r\n\r\nfunction hsl2rgb(h: number, s: number, l: number): number {\r\n    h = Math.round(h);\r\n    s = Math.round(s);\r\n    l = Math.round(l);\r\n\r\n    h = h % 360;\r\n    s = Math.clamp(0, 99, s);\r\n    l = Math.clamp(0, 99, l);\r\n    let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\r\n    let h1 = Math.idiv(h, 60);//[0,6]\r\n    let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\r\n    let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\r\n    let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\r\n    let r$: number;\r\n    let g$: number;\r\n    let b$: number;\r\n    if (h1 == 0) {\r\n        r$ = c;\r\n        g$ = x;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 1) {\r\n        r$ = x;\r\n        g$ = c;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 2) {\r\n        r$ = 0;\r\n        g$ = c;\r\n        b$ = x;\r\n    }\r\n    else if (h1 == 3) {\r\n        r$ = 0;\r\n        g$ = x;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 4) {\r\n        r$ = x;\r\n        g$ = 0;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 5) {\r\n        r$ = c;\r\n        g$ = 0;\r\n        b$ = x;\r\n    }\r\n    let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\r\n    let r = r$ + m;\r\n    let g = g$ + m;\r\n    let b = b$ + m;\r\n    let rgb = ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF)\r\n    return rgb;\r\n}\r\n\r\n/*\r\nPlanetX color sensor\r\n*/\r\n\r\nnamespace ColorSensor {\r\n\r\n    const APDS9960_ADDR = 0x39\r\n    const APDS9960_ENABLE = 0x80\r\n    const APDS9960_ATIME = 0x81\r\n    const APDS9960_CONTROL = 0x8F\r\n    const APDS9960_STATUS = 0x93\r\n    const APDS9960_CDATAL = 0x94\r\n    const APDS9960_CDATAH = 0x95\r\n    const APDS9960_RDATAL = 0x96\r\n    const APDS9960_RDATAH = 0x97\r\n    const APDS9960_GDATAL = 0x98\r\n    const APDS9960_GDATAH = 0x99\r\n    const APDS9960_BDATAL = 0x9A\r\n    const APDS9960_BDATAH = 0x9B\r\n    const APDS9960_GCONF4 = 0xAB\r\n    const APDS9960_AICLEAR = 0xE7\r\n\r\n    let color_first_init = false\r\n    let color_new_init = false\r\n\r\n    function i2cwrite_color(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread_color(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    export function init() {\r\n\r\n        // init module\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ATIME, 252)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_CONTROL, 0x03)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_GCONF4, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_AICLEAR, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x01)\r\n        color_first_init = true\r\n\r\n        // set to color mode\r\n        let tmp = i2cread_color(APDS9960_ADDR, APDS9960_ENABLE) | 0x2;\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, tmp);\r\n    }\r\n\r\n    export function readColor(): Color {\r\n        let buf = pins.createBuffer(2)\r\n        let c = 0\r\n        let r = 0\r\n        let g = 0\r\n        let b = 0\r\n        let temp_c = 0\r\n        let temp_r = 0\r\n        let temp_g = 0\r\n        let temp_b = 0\r\n        let temp = 0\r\n\r\n        if (color_new_init == false && color_first_init == false) {\r\n            let i = 0;\r\n            while (i++ < 20) {\r\n                buf[0] = 0x81\r\n                buf[1] = 0xCA\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                buf[0] = 0x80\r\n                buf[1] = 0x17\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                basic.pause(50);\r\n\r\n                if ((i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256) != 0) {\r\n                    color_new_init = true\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (color_new_init == true) {\r\n            basic.pause(100);\r\n            c = i2cread_color(0x43, 0xA6) + i2cread_color(0x43, 0xA7) * 256;\r\n            r = i2cread_color(0x43, 0xA0) + i2cread_color(0x43, 0xA1) * 256;\r\n            g = i2cread_color(0x43, 0xA2) + i2cread_color(0x43, 0xA3) * 256;\r\n            b = i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256;\r\n\r\n            r *= 1.3 * 0.47 * 0.83\r\n            g *= 0.69 * 0.56 * 0.83\r\n            b *= 0.80 * 0.415 * 0.83\r\n            c *= 0.3\r\n\r\n            if (r > b && r > g) {\r\n                b *= 1.18;\r\n                g *= 0.95\r\n            }\r\n\r\n            temp_c = c\r\n            temp_r = r\r\n            temp_g = g\r\n            temp_b = b\r\n\r\n            r = Math.min(r, 4095.9356)\r\n            g = Math.min(g, 4095.9356)\r\n            b = Math.min(b, 4095.9356)\r\n            c = Math.min(c, 4095.9356)\r\n\r\n            if (temp_b < temp_g) {\r\n                temp = temp_b\r\n                temp_b = temp_g\r\n                temp_g = temp\r\n            }\r\n        }\r\n        else {\r\n            if (color_first_init == false)\r\n                init()\r\n            let tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            while (!tmp) {\r\n                basic.pause(5);\r\n                tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            }\r\n            c = i2cread_color(APDS9960_ADDR, APDS9960_CDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_CDATAH) * 256;\r\n            r = i2cread_color(APDS9960_ADDR, APDS9960_RDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_RDATAH) * 256;\r\n            g = i2cread_color(APDS9960_ADDR, APDS9960_GDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_GDATAH) * 256;\r\n            b = i2cread_color(APDS9960_ADDR, APDS9960_BDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_BDATAH) * 256;\r\n        }\r\n\r\n        // map to rgb based on clear channel\r\n        let avg = c / 3;\r\n        r = r * 255 / avg;\r\n        g = g * 255 / avg;\r\n        b = b * 255 / avg;\r\n\r\n        // translate rgb to hue\r\n        let hue = rgb2hsl(r, g, b)\r\n        if (color_new_init == true && hue >= 180 && hue <= 201 && temp_c >= 6000 && (temp_b - temp_g) < 1000 || (temp_r > 4096 && temp_g > 4096 && temp_b > 4096)) {\r\n            temp_c = Math.map(temp_c, 0, 15000, 0, 13000);\r\n            hue = 180 + (13000 - temp_c) / 1000.0;\r\n        }\r\n\r\n        // translate hue to color\r\n        if (hue > 330 || hue < 20)\r\n            return Color.Red\r\n        if (hue > 120 && 180 > hue)\r\n            return Color.Green\r\n        if (hue > 210 && 270 > hue)\r\n            return Color.Blue\r\n        if (hue > 190 && 210 > hue)\r\n            return Color.Cyan\r\n        if (hue > 260 && 330 > hue)\r\n            return Color.Magenta\r\n        if (hue > 30 && 120 > hue)\r\n            return Color.Yellow\r\n        if (hue >= 180 && 190 > hue)\r\n            return Color.White\r\n        return Color.Black\r\n    }\r\n\r\n}\r\n\r\n//ColorSensor.init()\r\n//let HEADING = input.compassHeading()\r\nlet ASSIGN = [\"none\", \"groen\", \"blauw\", \"geel\", \"zwart\", \"rood\", \"wit\",\r\n                \"oranje\", \"cyaan\", \"magenta\", \"indigo\", \"violet\", \"paars\"]\r\n\r\nfunction lift(dir: boolean) {\r\n    if (dir) { // down\r\n        for (let i = 340; i >= 0; i--) {\r\n            Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n            basic.pause(5)\r\n        }\r\n        for (let i = 15; i >= 0; i--) {\r\n            Nezha.servoAngle( Nezha.Servo.S2, 360 - i)\r\n            basic.pause(10)\r\n        }\r\n    }\r\n    else { // up\r\n        for (let i = 0; i <= 15; i++) {\r\n            Nezha.servoAngle( Nezha.Servo.S2, 360 - i)\r\n            basic.pause(10)\r\n        }\r\n        for (let i = 0; i <= 340; i++) {\r\n            Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n            basic.pause(5)\r\n        }\r\n    }\r\n}\r\n\r\nlift(false)\r\nbasic.pause(1000)\r\nlift(true)\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Forklift\"\r\n//% block.loc.nl=\"Heftruck\"\r\nnamespace CForklift {\r\n\r\n    //% block=\"move the lift down\"\r\n    //% block.loc.nl=\"beweeg de vork naar onderen\"\r\n    export function moveUp() {\r\n        Nezha.servoAngle(Nezha.Servo.S1, 180)\r\n    }\r\n\r\n    //% block=\"move the lift down\"\r\n    //% block.loc.nl=\"beweeg de vork naar onderen\"\r\n    export function moveDown() {\r\n        Nezha.servoAngle(Nezha.Servo.S1, 180)\r\n    }\r\n\r\n    //% block=\"assign %dest to box %color\"\r\n    //% block.loc.nl=\"wijs %dest toe aan vak %color\"\r\n    export function assign(dest: string, color: Color) {\r\n        let ix: number = color\r\n        ASSIGN[ix] = dest\r\n    }\r\n}","README.md":"","pxt.json":"{\n    \"name\": \"pxt-forklift\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-mecanum\": \"github:CBurg-College/pxt-mecanum#fde56d8c97bd92d2e7600e8cdf3c245f626b405e\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1753442294983,"editorVersion":"8.0.11","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nFrom here to the 'pxt-soccer-player' specific code,\r\nthe code below is a composition and refactoring of:\r\n- the ElecFreaks 'pxt-nezha' library:\r\n  https://github.com/elecfreaks/pxt-nezha/blob/master/main.ts\r\n- the ElecFreaks 'pxt-PlanetX' library:\r\n  https://github.com/elecfreaks/pxt-PlanetX/blob/master/basic.ts\r\nBoth under MIT-license.\r\n*/\r\n\r\nnamespace Nezha {\r\n\r\n    export enum Connector {\r\n        //% block=\"J1\" \r\n        J1 = DigitalPin.P8,\r\n        //% block=\"J2\"\r\n        J2 = DigitalPin.P12,\r\n        //% block=\"J3\"\r\n        J3 = DigitalPin.P14,\r\n        //% block=\"J4\"\r\n        J4 = DigitalPin.P16\r\n    }\r\n\r\n    export enum Servo {\r\n        //% block=\"S1\" \r\n        S1,\r\n        //% block=\"S2\"\r\n        S2,\r\n        //% block=\"S3\" \r\n        S3,\r\n        //% block=\"S4\"\r\n        S4\r\n    }\r\n\r\n    export enum Motor {\r\n        //% block=\"M1\"\r\n        M1,\r\n        //% block=\"M2\"\r\n        M2,\r\n        //% block=\"M3\"\r\n        M3,\r\n        //% block=\"M4\"\r\n        M4\r\n    }\r\n\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 100) speed = 100\r\n        else\r\n            if (speed < -100) speed = -100\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, 360, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n}\r\n\r\n/*\r\nGeneral color module\r\nUsed by ColorSensor\r\n*/\r\n\r\nenum Color {\r\n    //% block=\"none\"\r\n    //% block.loc.nl=\"geen\"\r\n    None,\r\n    //% block=\"green\"\r\n    //% block.loc.nl=\"groen\"\r\n    Green,\r\n    //% block=\"blue\"\r\n    //% block.loc.nl=\"blauw\"\r\n    Blue,\r\n    //% block=\"yellow\"\r\n    //% block.loc.nl=\"geel\"\r\n    Yellow,\r\n    //% block=\"black\"\r\n    //% block.loc.nl=\"zwart\"\r\n    Black,\r\n    //% block=\"red\"\r\n    //% block.loc.nl=\"rood\"\r\n    Red,\r\n    //% block=\"white\"\r\n    //% block.loc.nl=\"wit\"\r\n    White,\r\n    //% block=\"orange\"\r\n    //% block.loc.nl=\"oranje\"\r\n    Orange,\r\n    //% block=\"cyan\"\r\n    //% block.loc.nl=\"cyaan\"\r\n    Cyan,\r\n    //% block=\"magenta\"\r\n    //% block.loc.nl=\"magenta\"\r\n    Magenta,\r\n    //% block=\"indigo\"\r\n    //% block.loc.nl=\"indigo\"\r\n    Indigo,\r\n    //% block=\"violet\"\r\n    //% block.loc.nl=\"violet\"\r\n    Violet,\r\n    //% block=\"purple\"\r\n    //% block.loc.nl=\"paars\"\r\n    Purple\r\n}\r\n\r\nfunction rgb(color: Color): number {\r\n    let val = 0\r\n    switch (color) {\r\n        case Color.Green: val = 0x00FF00; break;\r\n        case Color.Blue: val = 0x0000FF; break;\r\n        case Color.Yellow: val = 0xFFFF00; break;\r\n        case Color.Black: val = 0x000000; break;\r\n        case Color.Red: val = 0xFF0000; break;\r\n        case Color.White: val = 0xFFFFFF; break;\r\n        case Color.Orange: val = 0xFFA500; break;\r\n        case Color.Cyan: val = 0x00FFFF; break;\r\n        case Color.Magenta: val = 0xFF00FF; break;\r\n        case Color.Indigo: val = 0x4b0082; break;\r\n        case Color.Violet: val = 0x8a2be2; break;\r\n        case Color.Purple: val = 0xFF00FF; break;\r\n    }\r\n    return val\r\n}\r\n\r\nfunction pack(red: number, green: number, blue: number): number {\r\n    let rgb = ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF)\r\n    return rgb;\r\n}\r\n\r\nfunction rgb2hsl(color_r: number, color_g: number, color_b: number): number {\r\n    let Hue = 0\r\n    let R = color_r * 100 / 255;\r\n    let G = color_g * 100 / 255;\r\n    let B = color_b * 100 / 255;\r\n    let maxVal = Math.max(R, Math.max(G, B))\r\n    let minVal = Math.min(R, Math.min(G, B))\r\n    let Delta = maxVal - minVal;\r\n\r\n    if (Delta < 0) {\r\n        Hue = 0;\r\n    }\r\n    else if (maxVal == R && G >= B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta)) / 100;\r\n    }\r\n    else if (maxVal == R && G < B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta) + 360 * 100) / 100;\r\n    }\r\n    else if (maxVal == G) {\r\n        Hue = (60 * ((B - R) * 100 / Delta) + 120 * 100) / 100;\r\n    }\r\n    else if (maxVal == B) {\r\n        Hue = (60 * ((R - G) * 100 / Delta) + 240 * 100) / 100;\r\n    }\r\n    return Hue\r\n}\r\n\r\nfunction hsl2rgb(h: number, s: number, l: number): number {\r\n    h = Math.round(h);\r\n    s = Math.round(s);\r\n    l = Math.round(l);\r\n\r\n    h = h % 360;\r\n    s = Math.clamp(0, 99, s);\r\n    l = Math.clamp(0, 99, l);\r\n    let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\r\n    let h1 = Math.idiv(h, 60);//[0,6]\r\n    let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\r\n    let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\r\n    let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\r\n    let r$: number;\r\n    let g$: number;\r\n    let b$: number;\r\n    if (h1 == 0) {\r\n        r$ = c;\r\n        g$ = x;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 1) {\r\n        r$ = x;\r\n        g$ = c;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 2) {\r\n        r$ = 0;\r\n        g$ = c;\r\n        b$ = x;\r\n    }\r\n    else if (h1 == 3) {\r\n        r$ = 0;\r\n        g$ = x;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 4) {\r\n        r$ = x;\r\n        g$ = 0;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 5) {\r\n        r$ = c;\r\n        g$ = 0;\r\n        b$ = x;\r\n    }\r\n    let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\r\n    let r = r$ + m;\r\n    let g = g$ + m;\r\n    let b = b$ + m;\r\n    let rgb = ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF)\r\n    return rgb;\r\n}\r\n\r\n/*\r\nPlanetX color sensor\r\n*/\r\n\r\nnamespace ColorSensor {\r\n\r\n    const APDS9960_ADDR = 0x39\r\n    const APDS9960_ENABLE = 0x80\r\n    const APDS9960_ATIME = 0x81\r\n    const APDS9960_CONTROL = 0x8F\r\n    const APDS9960_STATUS = 0x93\r\n    const APDS9960_CDATAL = 0x94\r\n    const APDS9960_CDATAH = 0x95\r\n    const APDS9960_RDATAL = 0x96\r\n    const APDS9960_RDATAH = 0x97\r\n    const APDS9960_GDATAL = 0x98\r\n    const APDS9960_GDATAH = 0x99\r\n    const APDS9960_BDATAL = 0x9A\r\n    const APDS9960_BDATAH = 0x9B\r\n    const APDS9960_GCONF4 = 0xAB\r\n    const APDS9960_AICLEAR = 0xE7\r\n\r\n    let color_first_init = false\r\n    let color_new_init = false\r\n\r\n    function i2cwrite_color(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread_color(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    export function init() {\r\n\r\n        // init module\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ATIME, 252)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_CONTROL, 0x03)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_GCONF4, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_AICLEAR, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x01)\r\n        color_first_init = true\r\n\r\n        // set to color mode\r\n        let tmp = i2cread_color(APDS9960_ADDR, APDS9960_ENABLE) | 0x2;\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, tmp);\r\n    }\r\n\r\n    export function readColor(): Color {\r\n        let buf = pins.createBuffer(2)\r\n        let c = 0\r\n        let r = 0\r\n        let g = 0\r\n        let b = 0\r\n        let temp_c = 0\r\n        let temp_r = 0\r\n        let temp_g = 0\r\n        let temp_b = 0\r\n        let temp = 0\r\n\r\n        if (color_new_init == false && color_first_init == false) {\r\n            let i = 0;\r\n            while (i++ < 20) {\r\n                buf[0] = 0x81\r\n                buf[1] = 0xCA\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                buf[0] = 0x80\r\n                buf[1] = 0x17\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                basic.pause(50);\r\n\r\n                if ((i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256) != 0) {\r\n                    color_new_init = true\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (color_new_init == true) {\r\n            basic.pause(100);\r\n            c = i2cread_color(0x43, 0xA6) + i2cread_color(0x43, 0xA7) * 256;\r\n            r = i2cread_color(0x43, 0xA0) + i2cread_color(0x43, 0xA1) * 256;\r\n            g = i2cread_color(0x43, 0xA2) + i2cread_color(0x43, 0xA3) * 256;\r\n            b = i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256;\r\n\r\n            r *= 1.3 * 0.47 * 0.83\r\n            g *= 0.69 * 0.56 * 0.83\r\n            b *= 0.80 * 0.415 * 0.83\r\n            c *= 0.3\r\n\r\n            if (r > b && r > g) {\r\n                b *= 1.18;\r\n                g *= 0.95\r\n            }\r\n\r\n            temp_c = c\r\n            temp_r = r\r\n            temp_g = g\r\n            temp_b = b\r\n\r\n            r = Math.min(r, 4095.9356)\r\n            g = Math.min(g, 4095.9356)\r\n            b = Math.min(b, 4095.9356)\r\n            c = Math.min(c, 4095.9356)\r\n\r\n            if (temp_b < temp_g) {\r\n                temp = temp_b\r\n                temp_b = temp_g\r\n                temp_g = temp\r\n            }\r\n        }\r\n        else {\r\n            if (color_first_init == false)\r\n                init()\r\n            let tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            while (!tmp) {\r\n                basic.pause(5);\r\n                tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            }\r\n            c = i2cread_color(APDS9960_ADDR, APDS9960_CDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_CDATAH) * 256;\r\n            r = i2cread_color(APDS9960_ADDR, APDS9960_RDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_RDATAH) * 256;\r\n            g = i2cread_color(APDS9960_ADDR, APDS9960_GDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_GDATAH) * 256;\r\n            b = i2cread_color(APDS9960_ADDR, APDS9960_BDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_BDATAH) * 256;\r\n        }\r\n\r\n        // map to rgb based on clear channel\r\n        let avg = c / 3;\r\n        r = r * 255 / avg;\r\n        g = g * 255 / avg;\r\n        b = b * 255 / avg;\r\n\r\n        // translate rgb to hue\r\n        let hue = rgb2hsl(r, g, b)\r\n        if (color_new_init == true && hue >= 180 && hue <= 201 && temp_c >= 6000 && (temp_b - temp_g) < 1000 || (temp_r > 4096 && temp_g > 4096 && temp_b > 4096)) {\r\n            temp_c = Math.map(temp_c, 0, 15000, 0, 13000);\r\n            hue = 180 + (13000 - temp_c) / 1000.0;\r\n        }\r\n\r\n        // translate hue to color\r\n        if (hue > 330 || hue < 20)\r\n            return Color.Red\r\n        if (hue > 120 && 180 > hue)\r\n            return Color.Green\r\n        if (hue > 210 && 270 > hue)\r\n            return Color.Blue\r\n        if (hue > 190 && 210 > hue)\r\n            return Color.Cyan\r\n        if (hue > 260 && 330 > hue)\r\n            return Color.Magenta\r\n        if (hue > 30 && 120 > hue)\r\n            return Color.Yellow\r\n        if (hue >= 180 && 190 > hue)\r\n            return Color.White\r\n        return Color.Black\r\n    }\r\n\r\n}\r\n\r\n//ColorSensor.init()\r\n//let HEADING = input.compassHeading()\r\nlet ASSIGN = [\"none\", \"groen\", \"blauw\", \"geel\", \"zwart\", \"rood\", \"wit\",\r\n                \"oranje\", \"cyaan\", \"magenta\", \"indigo\", \"violet\", \"paars\"]\r\n\r\nbasic.showLeds(`\r\n    . . . . .\r\n    . . . . .\r\n    . . # . .\r\n    . . . . .\r\n    . . . . .\r\n    `)\r\nbasic.pause(500)\r\nbasic.showIcon(IconNames.SmallSquare)\r\nbasic.pause(500)\r\nbasic.showIcon(IconNames.Square)\r\nbasic.pause(500)\r\nbasic.clearScreen()\r\nCForklift.lift(CForklift.Lift.Up)\r\nbasic.pause(500)\r\nCForklift.lift(CForklift.Lift.Down)\r\nbasic.showIcon(IconNames.Yes)\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Forklift\"\r\n//% block.loc.nl=\"Heftruck\"\r\nnamespace CForklift {\r\n\r\n    export enum Lift {\r\n        //% block=\"up\"\r\n        //% block.loc.nl=\"omhoog\"\r\n        Up,\r\n        //% block=\"down\"\r\n        //% block.loc.nl=\"omlaag\"\r\n        Down\r\n    }\r\n\r\n    //% block=\"move the lift %dir\"\r\n    //% block.loc.nl=\"beweeg de lift %dir\"\r\n    export function lift(dir: Lift) {\r\n        if (dir) { // down\r\n            for (let i = 320; i >= 0; i--) {\r\n                Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n                basic.pause(2)\r\n            }\r\n            Nezha.servoAngle( Nezha.Servo.S2, 350)\r\n            basic.pause(100)\r\n            Nezha.servoAngle( Nezha.Servo.S2, 360)\r\n        }\r\n        else { // up\r\n            Nezha.servoAngle( Nezha.Servo.S2, 350)\r\n            basic.pause(100)\r\n            Nezha.servoAngle( Nezha.Servo.S2, 340)\r\n            for (let i = 0; i <= 320; i++) {\r\n                Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n                basic.pause(2)\r\n            }\r\n        }\r\n    }\r\n\r\n    //% block=\"assign %dest to box %color\"\r\n    //% block.loc.nl=\"wijs %dest toe aan vak %color\"\r\n    export function assign(dest: string, color: Color) {\r\n        let ix: number = color\r\n        ASSIGN[ix] = dest\r\n    }\r\n}","README.md":"","pxt.json":"{\n    \"name\": \"pxt-forklift\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-mecanum\": \"github:CBurg-College/pxt-mecanum#fde56d8c97bd92d2e7600e8cdf3c245f626b405e\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1753447674021,"editorVersion":"8.0.11","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nFrom here to the 'pxt-soccer-player' specific code,\r\nthe code below is a composition and refactoring of:\r\n- the ElecFreaks 'pxt-nezha' library:\r\n  https://github.com/elecfreaks/pxt-nezha/blob/master/main.ts\r\n- the ElecFreaks 'pxt-PlanetX' library:\r\n  https://github.com/elecfreaks/pxt-PlanetX/blob/master/basic.ts\r\nBoth under MIT-license.\r\n*/\r\n\r\nnamespace Nezha {\r\n\r\n    export enum Connector {\r\n        //% block=\"J1\" \r\n        J1 = DigitalPin.P8,\r\n        //% block=\"J2\"\r\n        J2 = DigitalPin.P12,\r\n        //% block=\"J3\"\r\n        J3 = DigitalPin.P14,\r\n        //% block=\"J4\"\r\n        J4 = DigitalPin.P16\r\n    }\r\n\r\n    export enum Servo {\r\n        //% block=\"S1\" \r\n        S1,\r\n        //% block=\"S2\"\r\n        S2,\r\n        //% block=\"S3\" \r\n        S3,\r\n        //% block=\"S4\"\r\n        S4\r\n    }\r\n\r\n    export enum Motor {\r\n        //% block=\"M1\"\r\n        M1,\r\n        //% block=\"M2\"\r\n        M2,\r\n        //% block=\"M3\"\r\n        M3,\r\n        //% block=\"M4\"\r\n        M4\r\n    }\r\n\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 100) speed = 100\r\n        else\r\n            if (speed < -100) speed = -100\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, 360, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n}\r\n\r\n/*\r\nGeneral color module\r\nUsed by ColorSensor\r\n*/\r\n\r\nenum Color {\r\n    //% block=\"none\"\r\n    //% block.loc.nl=\"geen\"\r\n    None,\r\n    //% block=\"green\"\r\n    //% block.loc.nl=\"groen\"\r\n    Green,\r\n    //% block=\"blue\"\r\n    //% block.loc.nl=\"blauw\"\r\n    Blue,\r\n    //% block=\"yellow\"\r\n    //% block.loc.nl=\"geel\"\r\n    Yellow,\r\n    //% block=\"black\"\r\n    //% block.loc.nl=\"zwart\"\r\n    Black,\r\n    //% block=\"red\"\r\n    //% block.loc.nl=\"rood\"\r\n    Red,\r\n    //% block=\"white\"\r\n    //% block.loc.nl=\"wit\"\r\n    White,\r\n    //% block=\"orange\"\r\n    //% block.loc.nl=\"oranje\"\r\n    Orange,\r\n    //% block=\"cyan\"\r\n    //% block.loc.nl=\"cyaan\"\r\n    Cyan,\r\n    //% block=\"magenta\"\r\n    //% block.loc.nl=\"magenta\"\r\n    Magenta,\r\n    //% block=\"indigo\"\r\n    //% block.loc.nl=\"indigo\"\r\n    Indigo,\r\n    //% block=\"violet\"\r\n    //% block.loc.nl=\"violet\"\r\n    Violet,\r\n    //% block=\"purple\"\r\n    //% block.loc.nl=\"paars\"\r\n    Purple\r\n}\r\n\r\nfunction rgb(color: Color): number {\r\n    let val = 0\r\n    switch (color) {\r\n        case Color.Green: val = 0x00FF00; break;\r\n        case Color.Blue: val = 0x0000FF; break;\r\n        case Color.Yellow: val = 0xFFFF00; break;\r\n        case Color.Black: val = 0x000000; break;\r\n        case Color.Red: val = 0xFF0000; break;\r\n        case Color.White: val = 0xFFFFFF; break;\r\n        case Color.Orange: val = 0xFFA500; break;\r\n        case Color.Cyan: val = 0x00FFFF; break;\r\n        case Color.Magenta: val = 0xFF00FF; break;\r\n        case Color.Indigo: val = 0x4b0082; break;\r\n        case Color.Violet: val = 0x8a2be2; break;\r\n        case Color.Purple: val = 0xFF00FF; break;\r\n    }\r\n    return val\r\n}\r\n\r\nfunction pack(red: number, green: number, blue: number): number {\r\n    let rgb = ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF)\r\n    return rgb;\r\n}\r\n\r\nfunction rgb2hsl(color_r: number, color_g: number, color_b: number): number {\r\n    let Hue = 0\r\n    let R = color_r * 100 / 255;\r\n    let G = color_g * 100 / 255;\r\n    let B = color_b * 100 / 255;\r\n    let maxVal = Math.max(R, Math.max(G, B))\r\n    let minVal = Math.min(R, Math.min(G, B))\r\n    let Delta = maxVal - minVal;\r\n\r\n    if (Delta < 0) {\r\n        Hue = 0;\r\n    }\r\n    else if (maxVal == R && G >= B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta)) / 100;\r\n    }\r\n    else if (maxVal == R && G < B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta) + 360 * 100) / 100;\r\n    }\r\n    else if (maxVal == G) {\r\n        Hue = (60 * ((B - R) * 100 / Delta) + 120 * 100) / 100;\r\n    }\r\n    else if (maxVal == B) {\r\n        Hue = (60 * ((R - G) * 100 / Delta) + 240 * 100) / 100;\r\n    }\r\n    return Hue\r\n}\r\n\r\nfunction hsl2rgb(h: number, s: number, l: number): number {\r\n    h = Math.round(h);\r\n    s = Math.round(s);\r\n    l = Math.round(l);\r\n\r\n    h = h % 360;\r\n    s = Math.clamp(0, 99, s);\r\n    l = Math.clamp(0, 99, l);\r\n    let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\r\n    let h1 = Math.idiv(h, 60);//[0,6]\r\n    let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\r\n    let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\r\n    let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\r\n    let r$: number;\r\n    let g$: number;\r\n    let b$: number;\r\n    if (h1 == 0) {\r\n        r$ = c;\r\n        g$ = x;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 1) {\r\n        r$ = x;\r\n        g$ = c;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 2) {\r\n        r$ = 0;\r\n        g$ = c;\r\n        b$ = x;\r\n    }\r\n    else if (h1 == 3) {\r\n        r$ = 0;\r\n        g$ = x;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 4) {\r\n        r$ = x;\r\n        g$ = 0;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 5) {\r\n        r$ = c;\r\n        g$ = 0;\r\n        b$ = x;\r\n    }\r\n    let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\r\n    let r = r$ + m;\r\n    let g = g$ + m;\r\n    let b = b$ + m;\r\n    let rgb = ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF)\r\n    return rgb;\r\n}\r\n\r\n/*\r\nPlanetX color sensor\r\n*/\r\n\r\nnamespace ColorSensor {\r\n\r\n    const APDS9960_ADDR = 0x39\r\n    const APDS9960_ENABLE = 0x80\r\n    const APDS9960_ATIME = 0x81\r\n    const APDS9960_CONTROL = 0x8F\r\n    const APDS9960_STATUS = 0x93\r\n    const APDS9960_CDATAL = 0x94\r\n    const APDS9960_CDATAH = 0x95\r\n    const APDS9960_RDATAL = 0x96\r\n    const APDS9960_RDATAH = 0x97\r\n    const APDS9960_GDATAL = 0x98\r\n    const APDS9960_GDATAH = 0x99\r\n    const APDS9960_BDATAL = 0x9A\r\n    const APDS9960_BDATAH = 0x9B\r\n    const APDS9960_GCONF4 = 0xAB\r\n    const APDS9960_AICLEAR = 0xE7\r\n\r\n    let color_first_init = false\r\n    let color_new_init = false\r\n\r\n    function i2cwrite_color(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread_color(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    export function init() {\r\n\r\n        // init module\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ATIME, 252)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_CONTROL, 0x03)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_GCONF4, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_AICLEAR, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x01)\r\n        color_first_init = true\r\n\r\n        // set to color mode\r\n        let tmp = i2cread_color(APDS9960_ADDR, APDS9960_ENABLE) | 0x2;\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, tmp);\r\n    }\r\n\r\n    export function readColor(): Color {\r\n        let buf = pins.createBuffer(2)\r\n        let c = 0\r\n        let r = 0\r\n        let g = 0\r\n        let b = 0\r\n        let temp_c = 0\r\n        let temp_r = 0\r\n        let temp_g = 0\r\n        let temp_b = 0\r\n        let temp = 0\r\n\r\n        if (color_new_init == false && color_first_init == false) {\r\n            let i = 0;\r\n            while (i++ < 20) {\r\n                buf[0] = 0x81\r\n                buf[1] = 0xCA\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                buf[0] = 0x80\r\n                buf[1] = 0x17\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                basic.pause(50);\r\n\r\n                if ((i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256) != 0) {\r\n                    color_new_init = true\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (color_new_init == true) {\r\n            basic.pause(100);\r\n            c = i2cread_color(0x43, 0xA6) + i2cread_color(0x43, 0xA7) * 256;\r\n            r = i2cread_color(0x43, 0xA0) + i2cread_color(0x43, 0xA1) * 256;\r\n            g = i2cread_color(0x43, 0xA2) + i2cread_color(0x43, 0xA3) * 256;\r\n            b = i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256;\r\n\r\n            r *= 1.3 * 0.47 * 0.83\r\n            g *= 0.69 * 0.56 * 0.83\r\n            b *= 0.80 * 0.415 * 0.83\r\n            c *= 0.3\r\n\r\n            if (r > b && r > g) {\r\n                b *= 1.18;\r\n                g *= 0.95\r\n            }\r\n\r\n            temp_c = c\r\n            temp_r = r\r\n            temp_g = g\r\n            temp_b = b\r\n\r\n            r = Math.min(r, 4095.9356)\r\n            g = Math.min(g, 4095.9356)\r\n            b = Math.min(b, 4095.9356)\r\n            c = Math.min(c, 4095.9356)\r\n\r\n            if (temp_b < temp_g) {\r\n                temp = temp_b\r\n                temp_b = temp_g\r\n                temp_g = temp\r\n            }\r\n        }\r\n        else {\r\n            if (color_first_init == false)\r\n                init()\r\n            let tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            while (!tmp) {\r\n                basic.pause(5);\r\n                tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            }\r\n            c = i2cread_color(APDS9960_ADDR, APDS9960_CDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_CDATAH) * 256;\r\n            r = i2cread_color(APDS9960_ADDR, APDS9960_RDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_RDATAH) * 256;\r\n            g = i2cread_color(APDS9960_ADDR, APDS9960_GDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_GDATAH) * 256;\r\n            b = i2cread_color(APDS9960_ADDR, APDS9960_BDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_BDATAH) * 256;\r\n        }\r\n\r\n        // map to rgb based on clear channel\r\n        let avg = c / 3;\r\n        r = r * 255 / avg;\r\n        g = g * 255 / avg;\r\n        b = b * 255 / avg;\r\n\r\n        // translate rgb to hue\r\n        let hue = rgb2hsl(r, g, b)\r\n        if (color_new_init == true && hue >= 180 && hue <= 201 && temp_c >= 6000 && (temp_b - temp_g) < 1000 || (temp_r > 4096 && temp_g > 4096 && temp_b > 4096)) {\r\n            temp_c = Math.map(temp_c, 0, 15000, 0, 13000);\r\n            hue = 180 + (13000 - temp_c) / 1000.0;\r\n        }\r\n\r\n        // translate hue to color\r\n        if (hue > 330 || hue < 20)\r\n            return Color.Red\r\n        if (hue > 120 && 180 > hue)\r\n            return Color.Green\r\n        if (hue > 210 && 270 > hue)\r\n            return Color.Blue\r\n        if (hue > 190 && 210 > hue)\r\n            return Color.Cyan\r\n        if (hue > 260 && 330 > hue)\r\n            return Color.Magenta\r\n        if (hue > 30 && 120 > hue)\r\n            return Color.Yellow\r\n        if (hue >= 180 && 190 > hue)\r\n            return Color.White\r\n        return Color.Black\r\n    }\r\n\r\n}\r\n\r\nCForklift.init()\r\n\r\nlet HEADING: number\r\nlet ASSIGN = [\"none\", \"groen\", \"blauw\", \"geel\", \"zwart\", \"rood\", \"wit\",\r\n                \"oranje\", \"cyaan\", \"magenta\", \"indigo\", \"violet\", \"paars\"]\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Forklift\"\r\n//% block.loc.nl=\"Heftruck\"\r\nnamespace CForklift {\r\n\r\n    export enum Lift {\r\n        //% block=\"up\"\r\n        //% block.loc.nl=\"omhoog\"\r\n        Up,\r\n        //% block=\"down\"\r\n        //% block.loc.nl=\"omlaag\"\r\n        Down\r\n    }\r\n\r\n    export function init() {\r\n        HEADING = input.compassHeading()\r\n        ColorSensor.init()\r\n        basic.showLeds(`\r\n            . . . . .\r\n            . . . . .\r\n            . . # . .\r\n            . . . . .\r\n            . . . . .\r\n            `)\r\n        basic.pause(500)\r\n        basic.showIcon(IconNames.SmallSquare)\r\n        basic.pause(500)\r\n        basic.showIcon(IconNames.Square)\r\n        basic.pause(500)\r\n        basic.clearScreen()\r\n        CForklift.lift(CForklift.Lift.Up)\r\n        basic.pause(500)\r\n        CForklift.lift(CForklift.Lift.Down)\r\n        basic.showIcon(IconNames.Yes)\r\n    }\r\n\r\n\r\n    //% block=\"move the lift %dir\"\r\n    //% block.loc.nl=\"beweeg de lift %dir\"\r\n    export function lift(dir: Lift) {\r\n        if (dir) { // down\r\n            for (let i = 320; i >= 0; i--) {\r\n                Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n                basic.pause(2)\r\n            }\r\n            Nezha.servoAngle( Nezha.Servo.S2, 350)\r\n            basic.pause(100)\r\n            Nezha.servoAngle( Nezha.Servo.S2, 360)\r\n        }\r\n        else { // up\r\n            Nezha.servoAngle( Nezha.Servo.S2, 350)\r\n            basic.pause(100)\r\n            Nezha.servoAngle( Nezha.Servo.S2, 340)\r\n            for (let i = 0; i <= 320; i++) {\r\n                Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n                basic.pause(2)\r\n            }\r\n        }\r\n    }\r\n\r\n    //% block=\"assign %dest to box %color\"\r\n    //% block.loc.nl=\"wijs %dest toe aan vak %color\"\r\n    export function assign(dest: string, color: Color) {\r\n        let ix: number = color\r\n        ASSIGN[ix] = dest\r\n    }\r\n}","README.md":"","pxt.json":"{\n    \"name\": \"pxt-forklift\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-mecanum\": \"github:CBurg-College/pxt-mecanum#fde56d8c97bd92d2e7600e8cdf3c245f626b405e\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1753456647630,"editorVersion":"8.0.11","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nFrom here to the 'pxt-soccer-player' specific code,\r\nthe code below is a composition and refactoring of:\r\n- the ElecFreaks 'pxt-nezha' library:\r\n  https://github.com/elecfreaks/pxt-nezha/blob/master/main.ts\r\n- the ElecFreaks 'pxt-PlanetX' library:\r\n  https://github.com/elecfreaks/pxt-PlanetX/blob/master/basic.ts\r\nBoth under MIT-license.\r\n*/\r\n\r\nnamespace Nezha {\r\n\r\n    export enum Connector {\r\n        //% block=\"J1\" \r\n        J1 = DigitalPin.P8,\r\n        //% block=\"J2\"\r\n        J2 = DigitalPin.P12,\r\n        //% block=\"J3\"\r\n        J3 = DigitalPin.P14,\r\n        //% block=\"J4\"\r\n        J4 = DigitalPin.P16\r\n    }\r\n\r\n    export enum Servo {\r\n        //% block=\"S1\" \r\n        S1,\r\n        //% block=\"S2\"\r\n        S2,\r\n        //% block=\"S3\" \r\n        S3,\r\n        //% block=\"S4\"\r\n        S4\r\n    }\r\n\r\n    export enum Motor {\r\n        //% block=\"M1\"\r\n        M1,\r\n        //% block=\"M2\"\r\n        M2,\r\n        //% block=\"M3\"\r\n        M3,\r\n        //% block=\"M4\"\r\n        M4\r\n    }\r\n\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 100) speed = 100\r\n        else\r\n            if (speed < -100) speed = -100\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, 360, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n}\r\n\r\n/*\r\nGeneral color module\r\nUsed by ColorSensor\r\n*/\r\n\r\nenum Color {\r\n    //% block=\"none\"\r\n    //% block.loc.nl=\"geen\"\r\n    None,\r\n    //% block=\"green\"\r\n    //% block.loc.nl=\"groen\"\r\n    Green,\r\n    //% block=\"blue\"\r\n    //% block.loc.nl=\"blauw\"\r\n    Blue,\r\n    //% block=\"yellow\"\r\n    //% block.loc.nl=\"geel\"\r\n    Yellow,\r\n    //% block=\"black\"\r\n    //% block.loc.nl=\"zwart\"\r\n    Black,\r\n    //% block=\"red\"\r\n    //% block.loc.nl=\"rood\"\r\n    Red,\r\n    //% block=\"white\"\r\n    //% block.loc.nl=\"wit\"\r\n    White,\r\n    //% block=\"orange\"\r\n    //% block.loc.nl=\"oranje\"\r\n    Orange,\r\n    //% block=\"cyan\"\r\n    //% block.loc.nl=\"cyaan\"\r\n    Cyan,\r\n    //% block=\"magenta\"\r\n    //% block.loc.nl=\"magenta\"\r\n    Magenta,\r\n    //% block=\"indigo\"\r\n    //% block.loc.nl=\"indigo\"\r\n    Indigo,\r\n    //% block=\"violet\"\r\n    //% block.loc.nl=\"violet\"\r\n    Violet,\r\n    //% block=\"purple\"\r\n    //% block.loc.nl=\"paars\"\r\n    Purple\r\n}\r\n\r\nfunction rgb(color: Color): number {\r\n    let val = 0\r\n    switch (color) {\r\n        case Color.Green: val = 0x00FF00; break;\r\n        case Color.Blue: val = 0x0000FF; break;\r\n        case Color.Yellow: val = 0xFFFF00; break;\r\n        case Color.Black: val = 0x000000; break;\r\n        case Color.Red: val = 0xFF0000; break;\r\n        case Color.White: val = 0xFFFFFF; break;\r\n        case Color.Orange: val = 0xFFA500; break;\r\n        case Color.Cyan: val = 0x00FFFF; break;\r\n        case Color.Magenta: val = 0xFF00FF; break;\r\n        case Color.Indigo: val = 0x4b0082; break;\r\n        case Color.Violet: val = 0x8a2be2; break;\r\n        case Color.Purple: val = 0xFF00FF; break;\r\n    }\r\n    return val\r\n}\r\n\r\nfunction pack(red: number, green: number, blue: number): number {\r\n    let rgb = ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF)\r\n    return rgb;\r\n}\r\n\r\nfunction rgb2hsl(color_r: number, color_g: number, color_b: number): number {\r\n    let Hue = 0\r\n    let R = color_r * 100 / 255;\r\n    let G = color_g * 100 / 255;\r\n    let B = color_b * 100 / 255;\r\n    let maxVal = Math.max(R, Math.max(G, B))\r\n    let minVal = Math.min(R, Math.min(G, B))\r\n    let Delta = maxVal - minVal;\r\n\r\n    if (Delta < 0) {\r\n        Hue = 0;\r\n    }\r\n    else if (maxVal == R && G >= B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta)) / 100;\r\n    }\r\n    else if (maxVal == R && G < B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta) + 360 * 100) / 100;\r\n    }\r\n    else if (maxVal == G) {\r\n        Hue = (60 * ((B - R) * 100 / Delta) + 120 * 100) / 100;\r\n    }\r\n    else if (maxVal == B) {\r\n        Hue = (60 * ((R - G) * 100 / Delta) + 240 * 100) / 100;\r\n    }\r\n    return Hue\r\n}\r\n\r\nfunction hsl2rgb(h: number, s: number, l: number): number {\r\n    h = Math.round(h);\r\n    s = Math.round(s);\r\n    l = Math.round(l);\r\n\r\n    h = h % 360;\r\n    s = Math.clamp(0, 99, s);\r\n    l = Math.clamp(0, 99, l);\r\n    let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\r\n    let h1 = Math.idiv(h, 60);//[0,6]\r\n    let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\r\n    let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\r\n    let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\r\n    let r$: number;\r\n    let g$: number;\r\n    let b$: number;\r\n    if (h1 == 0) {\r\n        r$ = c;\r\n        g$ = x;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 1) {\r\n        r$ = x;\r\n        g$ = c;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 2) {\r\n        r$ = 0;\r\n        g$ = c;\r\n        b$ = x;\r\n    }\r\n    else if (h1 == 3) {\r\n        r$ = 0;\r\n        g$ = x;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 4) {\r\n        r$ = x;\r\n        g$ = 0;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 5) {\r\n        r$ = c;\r\n        g$ = 0;\r\n        b$ = x;\r\n    }\r\n    let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\r\n    let r = r$ + m;\r\n    let g = g$ + m;\r\n    let b = b$ + m;\r\n    let rgb = ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF)\r\n    return rgb;\r\n}\r\n\r\n/*\r\nPlanetX color sensor\r\n*/\r\n\r\nnamespace ColorSensor {\r\n\r\n    const APDS9960_ADDR = 0x39\r\n    const APDS9960_ENABLE = 0x80\r\n    const APDS9960_ATIME = 0x81\r\n    const APDS9960_CONTROL = 0x8F\r\n    const APDS9960_STATUS = 0x93\r\n    const APDS9960_CDATAL = 0x94\r\n    const APDS9960_CDATAH = 0x95\r\n    const APDS9960_RDATAL = 0x96\r\n    const APDS9960_RDATAH = 0x97\r\n    const APDS9960_GDATAL = 0x98\r\n    const APDS9960_GDATAH = 0x99\r\n    const APDS9960_BDATAL = 0x9A\r\n    const APDS9960_BDATAH = 0x9B\r\n    const APDS9960_GCONF4 = 0xAB\r\n    const APDS9960_AICLEAR = 0xE7\r\n\r\n    let color_first_init = false\r\n    let color_new_init = false\r\n\r\n    function i2cwrite_color(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread_color(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    export function init() {\r\n\r\n        // init module\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ATIME, 252)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_CONTROL, 0x03)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_GCONF4, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_AICLEAR, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x01)\r\n        color_first_init = true\r\n\r\n        // set to color mode\r\n        let tmp = i2cread_color(APDS9960_ADDR, APDS9960_ENABLE) | 0x2;\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, tmp);\r\n    }\r\n\r\n    export function readColor(): Color {\r\n        let buf = pins.createBuffer(2)\r\n        let c = 0\r\n        let r = 0\r\n        let g = 0\r\n        let b = 0\r\n        let temp_c = 0\r\n        let temp_r = 0\r\n        let temp_g = 0\r\n        let temp_b = 0\r\n        let temp = 0\r\n\r\n        if (color_new_init == false && color_first_init == false) {\r\n            let i = 0;\r\n            while (i++ < 20) {\r\n                buf[0] = 0x81\r\n                buf[1] = 0xCA\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                buf[0] = 0x80\r\n                buf[1] = 0x17\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                basic.pause(50);\r\n\r\n                if ((i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256) != 0) {\r\n                    color_new_init = true\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (color_new_init == true) {\r\n            basic.pause(100);\r\n            c = i2cread_color(0x43, 0xA6) + i2cread_color(0x43, 0xA7) * 256;\r\n            r = i2cread_color(0x43, 0xA0) + i2cread_color(0x43, 0xA1) * 256;\r\n            g = i2cread_color(0x43, 0xA2) + i2cread_color(0x43, 0xA3) * 256;\r\n            b = i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256;\r\n\r\n            r *= 1.3 * 0.47 * 0.83\r\n            g *= 0.69 * 0.56 * 0.83\r\n            b *= 0.80 * 0.415 * 0.83\r\n            c *= 0.3\r\n\r\n            if (r > b && r > g) {\r\n                b *= 1.18;\r\n                g *= 0.95\r\n            }\r\n\r\n            temp_c = c\r\n            temp_r = r\r\n            temp_g = g\r\n            temp_b = b\r\n\r\n            r = Math.min(r, 4095.9356)\r\n            g = Math.min(g, 4095.9356)\r\n            b = Math.min(b, 4095.9356)\r\n            c = Math.min(c, 4095.9356)\r\n\r\n            if (temp_b < temp_g) {\r\n                temp = temp_b\r\n                temp_b = temp_g\r\n                temp_g = temp\r\n            }\r\n        }\r\n        else {\r\n            if (color_first_init == false)\r\n                init()\r\n            let tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            while (!tmp) {\r\n                basic.pause(5);\r\n                tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            }\r\n            c = i2cread_color(APDS9960_ADDR, APDS9960_CDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_CDATAH) * 256;\r\n            r = i2cread_color(APDS9960_ADDR, APDS9960_RDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_RDATAH) * 256;\r\n            g = i2cread_color(APDS9960_ADDR, APDS9960_GDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_GDATAH) * 256;\r\n            b = i2cread_color(APDS9960_ADDR, APDS9960_BDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_BDATAH) * 256;\r\n        }\r\n\r\n        // map to rgb based on clear channel\r\n        let avg = c / 3;\r\n        r = r * 255 / avg;\r\n        g = g * 255 / avg;\r\n        b = b * 255 / avg;\r\n\r\n        // translate rgb to hue\r\n        let hue = rgb2hsl(r, g, b)\r\n        if (color_new_init == true && hue >= 180 && hue <= 201 && temp_c >= 6000 && (temp_b - temp_g) < 1000 || (temp_r > 4096 && temp_g > 4096 && temp_b > 4096)) {\r\n            temp_c = Math.map(temp_c, 0, 15000, 0, 13000);\r\n            hue = 180 + (13000 - temp_c) / 1000.0;\r\n        }\r\n\r\n        // translate hue to color\r\n        if (hue > 330 || hue < 20)\r\n            return Color.Red\r\n        if (hue > 120 && 180 > hue)\r\n            return Color.Green\r\n        if (hue > 210 && 270 > hue)\r\n            return Color.Blue\r\n        if (hue > 190 && 210 > hue)\r\n            return Color.Cyan\r\n        if (hue > 260 && 330 > hue)\r\n            return Color.Magenta\r\n        if (hue > 30 && 120 > hue)\r\n            return Color.Yellow\r\n        if (hue >= 180 && 190 > hue)\r\n            return Color.White\r\n        return Color.Black\r\n    }\r\n\r\n}\r\n\r\nCForklift.init()\r\n\r\nlet HEADING: number\r\nlet ASSIGN = [\"none\", \"groen\", \"blauw\", \"geel\", \"zwart\", \"rood\", \"wit\",\r\n                \"oranje\", \"cyaan\", \"magenta\", \"indigo\", \"violet\", \"paars\"]\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Forklift\"\r\n//% block.loc.nl=\"Heftruck\"\r\nnamespace CForklift {\r\n\r\n    export enum Lift {\r\n        //% block=\"up\"\r\n        //% block.loc.nl=\"omhoog\"\r\n        Up,\r\n        //% block=\"down\"\r\n        //% block.loc.nl=\"omlaag\"\r\n        Down\r\n    }\r\n\r\n    export function init() {\r\n        HEADING = input.compassHeading()\r\n        ColorSensor.init()\r\n        basic.showLeds(`\r\n            . . . . .\r\n            . . . . .\r\n            . . # . .\r\n            . . . . .\r\n            . . . . .\r\n            `)\r\n        basic.pause(500)\r\n        basic.showIcon(IconNames.SmallSquare)\r\n        basic.pause(500)\r\n        basic.showIcon(IconNames.Square)\r\n        basic.pause(500)\r\n        basic.clearScreen()\r\n        CForklift.lift(CForklift.Lift.Up)\r\n        basic.pause(500)\r\n        CForklift.lift(CForklift.Lift.Down)\r\n        basic.showIcon(IconNames.Yes)\r\n    }\r\n\r\n\r\n    //% block=\"move the lift %dir\"\r\n    //% block.loc.nl=\"beweeg de lift %dir\"\r\n    export function lift(dir: Lift) {\r\n        if (dir) { // down\r\n            for (let i = 320; i >= 0; i--) {\r\n                Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n                basic.pause(2)\r\n            }\r\n            Nezha.servoAngle( Nezha.Servo.S2, 350)\r\n            basic.pause(100)\r\n            Nezha.servoAngle( Nezha.Servo.S2, 360)\r\n        }\r\n        else { // up\r\n            Nezha.servoAngle( Nezha.Servo.S2, 350)\r\n            basic.pause(100)\r\n            Nezha.servoAngle( Nezha.Servo.S2, 340)\r\n            for (let i = 0; i <= 320; i++) {\r\n                Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n                basic.pause(2)\r\n            }\r\n        }\r\n    }\r\n\r\n    //% block=\"assign %dest to box %color\"\r\n    //% block.loc.nl=\"wijs %dest toe aan vak %color\"\r\n    export function assign(dest: string, color: Color) {\r\n        let ix: number = color\r\n        ASSIGN[ix] = dest\r\n    }\r\n}","README.md":"","pxt.json":"{\n    \"name\": \"pxt-forklift\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-mecanum\": \"github:CBurg-College/pxt-mecanum#fde56d8c97bd92d2e7600e8cdf3c245f626b405e\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1753464080602,"editorVersion":"8.0.11","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nFrom here to the 'pxt-soccer-player' specific code,\r\nthe code below is a composition and refactoring of:\r\n- the ElecFreaks 'pxt-nezha' library:\r\n  https://github.com/elecfreaks/pxt-nezha/blob/master/main.ts\r\n- the ElecFreaks 'pxt-PlanetX' library:\r\n  https://github.com/elecfreaks/pxt-PlanetX/blob/master/basic.ts\r\nBoth under MIT-license.\r\n*/\r\n\r\nnamespace Nezha {\r\n\r\n    export enum Connector {\r\n        //% block=\"J1\" \r\n        J1 = DigitalPin.P8,\r\n        //% block=\"J2\"\r\n        J2 = DigitalPin.P12,\r\n        //% block=\"J3\"\r\n        J3 = DigitalPin.P14,\r\n        //% block=\"J4\"\r\n        J4 = DigitalPin.P16\r\n    }\r\n\r\n    export enum Servo {\r\n        //% block=\"S1\" \r\n        S1,\r\n        //% block=\"S2\"\r\n        S2,\r\n        //% block=\"S3\" \r\n        S3,\r\n        //% block=\"S4\"\r\n        S4\r\n    }\r\n\r\n    export enum Motor {\r\n        //% block=\"M1\"\r\n        M1,\r\n        //% block=\"M2\"\r\n        M2,\r\n        //% block=\"M3\"\r\n        M3,\r\n        //% block=\"M4\"\r\n        M4\r\n    }\r\n\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 100) speed = 100\r\n        else\r\n            if (speed < -100) speed = -100\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, 360, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n}\r\n\r\n/*\r\nGeneral color module\r\nUsed by ColorSensor\r\n*/\r\n\r\nenum Color {\r\n    //% block=\"none\"\r\n    //% block.loc.nl=\"geen\"\r\n    None,\r\n    //% block=\"green\"\r\n    //% block.loc.nl=\"groen\"\r\n    Green,\r\n    //% block=\"blue\"\r\n    //% block.loc.nl=\"blauw\"\r\n    Blue,\r\n    //% block=\"yellow\"\r\n    //% block.loc.nl=\"geel\"\r\n    Yellow,\r\n    //% block=\"black\"\r\n    //% block.loc.nl=\"zwart\"\r\n    Black,\r\n    //% block=\"red\"\r\n    //% block.loc.nl=\"rood\"\r\n    Red,\r\n    //% block=\"white\"\r\n    //% block.loc.nl=\"wit\"\r\n    White,\r\n    //% block=\"orange\"\r\n    //% block.loc.nl=\"oranje\"\r\n    Orange,\r\n    //% block=\"cyan\"\r\n    //% block.loc.nl=\"cyaan\"\r\n    Cyan,\r\n    //% block=\"magenta\"\r\n    //% block.loc.nl=\"magenta\"\r\n    Magenta,\r\n    //% block=\"indigo\"\r\n    //% block.loc.nl=\"indigo\"\r\n    Indigo,\r\n    //% block=\"violet\"\r\n    //% block.loc.nl=\"violet\"\r\n    Violet,\r\n    //% block=\"purple\"\r\n    //% block.loc.nl=\"paars\"\r\n    Purple\r\n}\r\n\r\nfunction rgb(color: Color): number {\r\n    let val = 0\r\n    switch (color) {\r\n        case Color.Green: val = 0x00FF00; break;\r\n        case Color.Blue: val = 0x0000FF; break;\r\n        case Color.Yellow: val = 0xFFFF00; break;\r\n        case Color.Black: val = 0x000000; break;\r\n        case Color.Red: val = 0xFF0000; break;\r\n        case Color.White: val = 0xFFFFFF; break;\r\n        case Color.Orange: val = 0xFFA500; break;\r\n        case Color.Cyan: val = 0x00FFFF; break;\r\n        case Color.Magenta: val = 0xFF00FF; break;\r\n        case Color.Indigo: val = 0x4b0082; break;\r\n        case Color.Violet: val = 0x8a2be2; break;\r\n        case Color.Purple: val = 0xFF00FF; break;\r\n    }\r\n    return val\r\n}\r\n\r\nfunction pack(red: number, green: number, blue: number): number {\r\n    let rgb = ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF)\r\n    return rgb;\r\n}\r\n\r\nfunction rgb2hsl(color_r: number, color_g: number, color_b: number): number {\r\n    let Hue = 0\r\n    let R = color_r * 100 / 255;\r\n    let G = color_g * 100 / 255;\r\n    let B = color_b * 100 / 255;\r\n    let maxVal = Math.max(R, Math.max(G, B))\r\n    let minVal = Math.min(R, Math.min(G, B))\r\n    let Delta = maxVal - minVal;\r\n\r\n    if (Delta < 0) {\r\n        Hue = 0;\r\n    }\r\n    else if (maxVal == R && G >= B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta)) / 100;\r\n    }\r\n    else if (maxVal == R && G < B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta) + 360 * 100) / 100;\r\n    }\r\n    else if (maxVal == G) {\r\n        Hue = (60 * ((B - R) * 100 / Delta) + 120 * 100) / 100;\r\n    }\r\n    else if (maxVal == B) {\r\n        Hue = (60 * ((R - G) * 100 / Delta) + 240 * 100) / 100;\r\n    }\r\n    return Hue\r\n}\r\n\r\nfunction hsl2rgb(h: number, s: number, l: number): number {\r\n    h = Math.round(h);\r\n    s = Math.round(s);\r\n    l = Math.round(l);\r\n\r\n    h = h % 360;\r\n    s = Math.clamp(0, 99, s);\r\n    l = Math.clamp(0, 99, l);\r\n    let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\r\n    let h1 = Math.idiv(h, 60);//[0,6]\r\n    let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\r\n    let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\r\n    let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\r\n    let r$: number;\r\n    let g$: number;\r\n    let b$: number;\r\n    if (h1 == 0) {\r\n        r$ = c;\r\n        g$ = x;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 1) {\r\n        r$ = x;\r\n        g$ = c;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 2) {\r\n        r$ = 0;\r\n        g$ = c;\r\n        b$ = x;\r\n    }\r\n    else if (h1 == 3) {\r\n        r$ = 0;\r\n        g$ = x;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 4) {\r\n        r$ = x;\r\n        g$ = 0;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 5) {\r\n        r$ = c;\r\n        g$ = 0;\r\n        b$ = x;\r\n    }\r\n    let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\r\n    let r = r$ + m;\r\n    let g = g$ + m;\r\n    let b = b$ + m;\r\n    let rgb = ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF)\r\n    return rgb;\r\n}\r\n\r\n/*\r\nPlanetX color sensor\r\n*/\r\n\r\nnamespace ColorSensor {\r\n\r\n    const APDS9960_ADDR = 0x39\r\n    const APDS9960_ENABLE = 0x80\r\n    const APDS9960_ATIME = 0x81\r\n    const APDS9960_CONTROL = 0x8F\r\n    const APDS9960_STATUS = 0x93\r\n    const APDS9960_CDATAL = 0x94\r\n    const APDS9960_CDATAH = 0x95\r\n    const APDS9960_RDATAL = 0x96\r\n    const APDS9960_RDATAH = 0x97\r\n    const APDS9960_GDATAL = 0x98\r\n    const APDS9960_GDATAH = 0x99\r\n    const APDS9960_BDATAL = 0x9A\r\n    const APDS9960_BDATAH = 0x9B\r\n    const APDS9960_GCONF4 = 0xAB\r\n    const APDS9960_AICLEAR = 0xE7\r\n\r\n    let color_first_init = false\r\n    let color_new_init = false\r\n\r\n    function i2cwrite_color(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread_color(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    export function init() {\r\n\r\n        // init module\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ATIME, 252)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_CONTROL, 0x03)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_GCONF4, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_AICLEAR, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x01)\r\n        color_first_init = true\r\n\r\n        // set to color mode\r\n        let tmp = i2cread_color(APDS9960_ADDR, APDS9960_ENABLE) | 0x2;\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, tmp);\r\n    }\r\n\r\n    export function readColor(): Color {\r\n        let buf = pins.createBuffer(2)\r\n        let c = 0\r\n        let r = 0\r\n        let g = 0\r\n        let b = 0\r\n        let temp_c = 0\r\n        let temp_r = 0\r\n        let temp_g = 0\r\n        let temp_b = 0\r\n        let temp = 0\r\n\r\n        if (color_new_init == false && color_first_init == false) {\r\n            let i = 0;\r\n            while (i++ < 20) {\r\n                buf[0] = 0x81\r\n                buf[1] = 0xCA\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                buf[0] = 0x80\r\n                buf[1] = 0x17\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                basic.pause(50);\r\n\r\n                if ((i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256) != 0) {\r\n                    color_new_init = true\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (color_new_init == true) {\r\n            basic.pause(100);\r\n            c = i2cread_color(0x43, 0xA6) + i2cread_color(0x43, 0xA7) * 256;\r\n            r = i2cread_color(0x43, 0xA0) + i2cread_color(0x43, 0xA1) * 256;\r\n            g = i2cread_color(0x43, 0xA2) + i2cread_color(0x43, 0xA3) * 256;\r\n            b = i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256;\r\n\r\n            r *= 1.3 * 0.47 * 0.83\r\n            g *= 0.69 * 0.56 * 0.83\r\n            b *= 0.80 * 0.415 * 0.83\r\n            c *= 0.3\r\n\r\n            if (r > b && r > g) {\r\n                b *= 1.18;\r\n                g *= 0.95\r\n            }\r\n\r\n            temp_c = c\r\n            temp_r = r\r\n            temp_g = g\r\n            temp_b = b\r\n\r\n            r = Math.min(r, 4095.9356)\r\n            g = Math.min(g, 4095.9356)\r\n            b = Math.min(b, 4095.9356)\r\n            c = Math.min(c, 4095.9356)\r\n\r\n            if (temp_b < temp_g) {\r\n                temp = temp_b\r\n                temp_b = temp_g\r\n                temp_g = temp\r\n            }\r\n        }\r\n        else {\r\n            if (color_first_init == false)\r\n                init()\r\n            let tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            while (!tmp) {\r\n                basic.pause(5);\r\n                tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            }\r\n            c = i2cread_color(APDS9960_ADDR, APDS9960_CDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_CDATAH) * 256;\r\n            r = i2cread_color(APDS9960_ADDR, APDS9960_RDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_RDATAH) * 256;\r\n            g = i2cread_color(APDS9960_ADDR, APDS9960_GDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_GDATAH) * 256;\r\n            b = i2cread_color(APDS9960_ADDR, APDS9960_BDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_BDATAH) * 256;\r\n        }\r\n\r\n        // map to rgb based on clear channel\r\n        let avg = c / 3;\r\n        r = r * 255 / avg;\r\n        g = g * 255 / avg;\r\n        b = b * 255 / avg;\r\n\r\n        // translate rgb to hue\r\n        let hue = rgb2hsl(r, g, b)\r\n        if (color_new_init == true && hue >= 180 && hue <= 201 && temp_c >= 6000 && (temp_b - temp_g) < 1000 || (temp_r > 4096 && temp_g > 4096 && temp_b > 4096)) {\r\n            temp_c = Math.map(temp_c, 0, 15000, 0, 13000);\r\n            hue = 180 + (13000 - temp_c) / 1000.0;\r\n        }\r\n\r\n        // translate hue to color\r\n        if (hue > 330 || hue < 20)\r\n            return Color.Red\r\n        if (hue > 120 && 180 > hue)\r\n            return Color.Green\r\n        if (hue > 210 && 270 > hue)\r\n            return Color.Blue\r\n        if (hue > 190 && 210 > hue)\r\n            return Color.Cyan\r\n        if (hue > 260 && 330 > hue)\r\n            return Color.Magenta\r\n        if (hue > 30 && 120 > hue)\r\n            return Color.Yellow\r\n        if (hue >= 180 && 190 > hue)\r\n            return Color.White\r\n        return Color.Black\r\n    }\r\n\r\n}\r\n\r\nCForklift.init()\r\n\r\nlet HEADING: number\r\nlet ASSIGN = [\"none\", \"groen\", \"blauw\", \"geel\", \"zwart\", \"rood\", \"wit\",\r\n                \"oranje\", \"cyaan\", \"magenta\", \"indigo\", \"violet\", \"paars\"]\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Forklift\"\r\n//% block.loc.nl=\"Heftruck\"\r\nnamespace CForklift {\r\n\r\n    export enum Lift {\r\n        //% block=\"up\"\r\n        //% block.loc.nl=\"omhoog\"\r\n        Up,\r\n        //% block=\"down\"\r\n        //% block.loc.nl=\"omlaag\"\r\n        Down\r\n    }\r\n\r\n    export function init() {\r\n        HEADING = input.compassHeading()\r\n        ColorSensor.init()\r\n        basic.showLeds(`\r\n            . . . . .\r\n            . . . . .\r\n            . . # . .\r\n            . . . . .\r\n            . . . . .\r\n            `)\r\n        basic.pause(500)\r\n        basic.showIcon(IconNames.SmallSquare)\r\n        basic.pause(500)\r\n        basic.showIcon(IconNames.Square)\r\n        basic.pause(500)\r\n        basic.clearScreen()\r\n        CForklift.lift(CForklift.Lift.Up)\r\n        basic.pause(500)\r\n        CForklift.lift(CForklift.Lift.Down)\r\n        basic.showIcon(IconNames.Yes)\r\n    }\r\n\r\n    //% block=\"is loaded\"\r\n    //% block.loc.nl=\"is geladen\"\r\n    export function isLoaded() : boolean {\r\n        pins.setPull(Nezha.Connector.J1, PinPullMode.PullUp)\r\n        return (pins.digitalReadPin(Nezha.Connector.J1) == 0)\r\n    }\r\n\r\n    //% block=\"move the lift %dir\"\r\n    //% block.loc.nl=\"beweeg de lift %dir\"\r\n    export function lift(dir: Lift) {\r\n        if (dir) { // down\r\n            for (let i = 320; i >= 0; i--) {\r\n                Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n                basic.pause(2)\r\n            }\r\n            Nezha.servoAngle( Nezha.Servo.S2, 350)\r\n            basic.pause(100)\r\n            Nezha.servoAngle( Nezha.Servo.S2, 360)\r\n        }\r\n        else { // up\r\n            Nezha.servoAngle( Nezha.Servo.S2, 350)\r\n            basic.pause(100)\r\n            Nezha.servoAngle( Nezha.Servo.S2, 340)\r\n            for (let i = 0; i <= 320; i++) {\r\n                Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n                basic.pause(2)\r\n            }\r\n        }\r\n    }\r\n\r\n    //% block=\"assign %dest to box %color\"\r\n    //% block.loc.nl=\"wijs %dest toe aan vak %color\"\r\n    export function assign(dest: string, color: Color) {\r\n        let ix: number = color\r\n        ASSIGN[ix] = dest\r\n    }\r\n}\r\n\r\nif (CForklift.isLoaded())\r\n    basic.showNumber(1)\r\nelse\r\n    basic.showNumber(0)","README.md":"","pxt.json":"{\n    \"name\": \"pxt-forklift\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-mecanum\": \"github:CBurg-College/pxt-mecanum#fde56d8c97bd92d2e7600e8cdf3c245f626b405e\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1753466857866,"editorVersion":"8.0.11","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nFrom here to the 'pxt-soccer-player' specific code,\r\nthe code below is a composition and refactoring of:\r\n- the ElecFreaks 'pxt-nezha' library:\r\n  https://github.com/elecfreaks/pxt-nezha/blob/master/main.ts\r\n- the ElecFreaks 'pxt-PlanetX' library:\r\n  https://github.com/elecfreaks/pxt-PlanetX/blob/master/basic.ts\r\nBoth under MIT-license.\r\n*/\r\n\r\nnamespace Nezha {\r\n\r\n    export enum Connector {\r\n        //% block=\"J1\" \r\n        J1 = DigitalPin.P8,\r\n        //% block=\"J2\"\r\n        J2 = DigitalPin.P12,\r\n        //% block=\"J3\"\r\n        J3 = DigitalPin.P14,\r\n        //% block=\"J4\"\r\n        J4 = DigitalPin.P16\r\n    }\r\n\r\n    export enum Servo {\r\n        //% block=\"S1\" \r\n        S1,\r\n        //% block=\"S2\"\r\n        S2,\r\n        //% block=\"S3\" \r\n        S3,\r\n        //% block=\"S4\"\r\n        S4\r\n    }\r\n\r\n    export enum Motor {\r\n        //% block=\"M1\"\r\n        M1,\r\n        //% block=\"M2\"\r\n        M2,\r\n        //% block=\"M3\"\r\n        M3,\r\n        //% block=\"M4\"\r\n        M4\r\n    }\r\n\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 100) speed = 100\r\n        else\r\n            if (speed < -100) speed = -100\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, 360, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n}\r\n\r\n/*\r\nGeneral color module\r\nUsed by ColorSensor\r\n*/\r\n\r\nenum Color {\r\n    //% block=\"none\"\r\n    //% block.loc.nl=\"geen\"\r\n    None,\r\n    //% block=\"green\"\r\n    //% block.loc.nl=\"groen\"\r\n    Green,\r\n    //% block=\"blue\"\r\n    //% block.loc.nl=\"blauw\"\r\n    Blue,\r\n    //% block=\"yellow\"\r\n    //% block.loc.nl=\"geel\"\r\n    Yellow,\r\n    //% block=\"black\"\r\n    //% block.loc.nl=\"zwart\"\r\n    Black,\r\n    //% block=\"red\"\r\n    //% block.loc.nl=\"rood\"\r\n    Red,\r\n    //% block=\"white\"\r\n    //% block.loc.nl=\"wit\"\r\n    White,\r\n    //% block=\"orange\"\r\n    //% block.loc.nl=\"oranje\"\r\n    Orange,\r\n    //% block=\"cyan\"\r\n    //% block.loc.nl=\"cyaan\"\r\n    Cyan,\r\n    //% block=\"magenta\"\r\n    //% block.loc.nl=\"magenta\"\r\n    Magenta,\r\n    //% block=\"indigo\"\r\n    //% block.loc.nl=\"indigo\"\r\n    Indigo,\r\n    //% block=\"violet\"\r\n    //% block.loc.nl=\"violet\"\r\n    Violet,\r\n    //% block=\"purple\"\r\n    //% block.loc.nl=\"paars\"\r\n    Purple\r\n}\r\n\r\nfunction rgb(color: Color): number {\r\n    let val = 0\r\n    switch (color) {\r\n        case Color.Green: val = 0x00FF00; break;\r\n        case Color.Blue: val = 0x0000FF; break;\r\n        case Color.Yellow: val = 0xFFFF00; break;\r\n        case Color.Black: val = 0x000000; break;\r\n        case Color.Red: val = 0xFF0000; break;\r\n        case Color.White: val = 0xFFFFFF; break;\r\n        case Color.Orange: val = 0xFFA500; break;\r\n        case Color.Cyan: val = 0x00FFFF; break;\r\n        case Color.Magenta: val = 0xFF00FF; break;\r\n        case Color.Indigo: val = 0x4b0082; break;\r\n        case Color.Violet: val = 0x8a2be2; break;\r\n        case Color.Purple: val = 0xFF00FF; break;\r\n    }\r\n    return val\r\n}\r\n\r\nfunction pack(red: number, green: number, blue: number): number {\r\n    let rgb = ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF)\r\n    return rgb;\r\n}\r\n\r\nfunction rgb2hsl(color_r: number, color_g: number, color_b: number): number {\r\n    let Hue = 0\r\n    let R = color_r * 100 / 255;\r\n    let G = color_g * 100 / 255;\r\n    let B = color_b * 100 / 255;\r\n    let maxVal = Math.max(R, Math.max(G, B))\r\n    let minVal = Math.min(R, Math.min(G, B))\r\n    let Delta = maxVal - minVal;\r\n\r\n    if (Delta < 0) {\r\n        Hue = 0;\r\n    }\r\n    else if (maxVal == R && G >= B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta)) / 100;\r\n    }\r\n    else if (maxVal == R && G < B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta) + 360 * 100) / 100;\r\n    }\r\n    else if (maxVal == G) {\r\n        Hue = (60 * ((B - R) * 100 / Delta) + 120 * 100) / 100;\r\n    }\r\n    else if (maxVal == B) {\r\n        Hue = (60 * ((R - G) * 100 / Delta) + 240 * 100) / 100;\r\n    }\r\n    return Hue\r\n}\r\n\r\nfunction hsl2rgb(h: number, s: number, l: number): number {\r\n    h = Math.round(h);\r\n    s = Math.round(s);\r\n    l = Math.round(l);\r\n\r\n    h = h % 360;\r\n    s = Math.clamp(0, 99, s);\r\n    l = Math.clamp(0, 99, l);\r\n    let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\r\n    let h1 = Math.idiv(h, 60);//[0,6]\r\n    let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\r\n    let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\r\n    let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\r\n    let r$: number;\r\n    let g$: number;\r\n    let b$: number;\r\n    if (h1 == 0) {\r\n        r$ = c;\r\n        g$ = x;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 1) {\r\n        r$ = x;\r\n        g$ = c;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 2) {\r\n        r$ = 0;\r\n        g$ = c;\r\n        b$ = x;\r\n    }\r\n    else if (h1 == 3) {\r\n        r$ = 0;\r\n        g$ = x;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 4) {\r\n        r$ = x;\r\n        g$ = 0;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 5) {\r\n        r$ = c;\r\n        g$ = 0;\r\n        b$ = x;\r\n    }\r\n    let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\r\n    let r = r$ + m;\r\n    let g = g$ + m;\r\n    let b = b$ + m;\r\n    let rgb = ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF)\r\n    return rgb;\r\n}\r\n\r\n/*\r\nPlanetX color sensor\r\n*/\r\n\r\nnamespace ColorSensor {\r\n\r\n    const APDS9960_ADDR = 0x39\r\n    const APDS9960_ENABLE = 0x80\r\n    const APDS9960_ATIME = 0x81\r\n    const APDS9960_CONTROL = 0x8F\r\n    const APDS9960_STATUS = 0x93\r\n    const APDS9960_CDATAL = 0x94\r\n    const APDS9960_CDATAH = 0x95\r\n    const APDS9960_RDATAL = 0x96\r\n    const APDS9960_RDATAH = 0x97\r\n    const APDS9960_GDATAL = 0x98\r\n    const APDS9960_GDATAH = 0x99\r\n    const APDS9960_BDATAL = 0x9A\r\n    const APDS9960_BDATAH = 0x9B\r\n    const APDS9960_GCONF4 = 0xAB\r\n    const APDS9960_AICLEAR = 0xE7\r\n\r\n    let color_first_init = false\r\n    let color_new_init = false\r\n\r\n    function i2cwrite_color(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread_color(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    export function init() {\r\n\r\n        // init module\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ATIME, 252)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_CONTROL, 0x03)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_GCONF4, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_AICLEAR, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x01)\r\n        color_first_init = true\r\n\r\n        // set to color mode\r\n        let tmp = i2cread_color(APDS9960_ADDR, APDS9960_ENABLE) | 0x2;\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, tmp);\r\n    }\r\n\r\n    export function readColor(): Color {\r\n        let buf = pins.createBuffer(2)\r\n        let c = 0\r\n        let r = 0\r\n        let g = 0\r\n        let b = 0\r\n        let temp_c = 0\r\n        let temp_r = 0\r\n        let temp_g = 0\r\n        let temp_b = 0\r\n        let temp = 0\r\n\r\n        if (color_new_init == false && color_first_init == false) {\r\n            let i = 0;\r\n            while (i++ < 20) {\r\n                buf[0] = 0x81\r\n                buf[1] = 0xCA\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                buf[0] = 0x80\r\n                buf[1] = 0x17\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                basic.pause(50);\r\n\r\n                if ((i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256) != 0) {\r\n                    color_new_init = true\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (color_new_init == true) {\r\n            basic.pause(100);\r\n            c = i2cread_color(0x43, 0xA6) + i2cread_color(0x43, 0xA7) * 256;\r\n            r = i2cread_color(0x43, 0xA0) + i2cread_color(0x43, 0xA1) * 256;\r\n            g = i2cread_color(0x43, 0xA2) + i2cread_color(0x43, 0xA3) * 256;\r\n            b = i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256;\r\n\r\n            r *= 1.3 * 0.47 * 0.83\r\n            g *= 0.69 * 0.56 * 0.83\r\n            b *= 0.80 * 0.415 * 0.83\r\n            c *= 0.3\r\n\r\n            if (r > b && r > g) {\r\n                b *= 1.18;\r\n                g *= 0.95\r\n            }\r\n\r\n            temp_c = c\r\n            temp_r = r\r\n            temp_g = g\r\n            temp_b = b\r\n\r\n            r = Math.min(r, 4095.9356)\r\n            g = Math.min(g, 4095.9356)\r\n            b = Math.min(b, 4095.9356)\r\n            c = Math.min(c, 4095.9356)\r\n\r\n            if (temp_b < temp_g) {\r\n                temp = temp_b\r\n                temp_b = temp_g\r\n                temp_g = temp\r\n            }\r\n        }\r\n        else {\r\n            if (color_first_init == false)\r\n                init()\r\n            let tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            while (!tmp) {\r\n                basic.pause(5);\r\n                tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            }\r\n            c = i2cread_color(APDS9960_ADDR, APDS9960_CDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_CDATAH) * 256;\r\n            r = i2cread_color(APDS9960_ADDR, APDS9960_RDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_RDATAH) * 256;\r\n            g = i2cread_color(APDS9960_ADDR, APDS9960_GDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_GDATAH) * 256;\r\n            b = i2cread_color(APDS9960_ADDR, APDS9960_BDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_BDATAH) * 256;\r\n        }\r\n\r\n        // map to rgb based on clear channel\r\n        let avg = c / 3;\r\n        r = r * 255 / avg;\r\n        g = g * 255 / avg;\r\n        b = b * 255 / avg;\r\n\r\n        // translate rgb to hue\r\n        let hue = rgb2hsl(r, g, b)\r\n        if (color_new_init == true && hue >= 180 && hue <= 201 && temp_c >= 6000 && (temp_b - temp_g) < 1000 || (temp_r > 4096 && temp_g > 4096 && temp_b > 4096)) {\r\n            temp_c = Math.map(temp_c, 0, 15000, 0, 13000);\r\n            hue = 180 + (13000 - temp_c) / 1000.0;\r\n        }\r\n\r\n        // translate hue to color\r\n        if (hue > 330 || hue < 20)\r\n            return Color.Red\r\n        if (hue > 120 && 180 > hue)\r\n            return Color.Green\r\n        if (hue > 210 && 270 > hue)\r\n            return Color.Blue\r\n        if (hue > 190 && 210 > hue)\r\n            return Color.Cyan\r\n        if (hue > 260 && 330 > hue)\r\n            return Color.Magenta\r\n        if (hue > 30 && 120 > hue)\r\n            return Color.Yellow\r\n        if (hue >= 180 && 190 > hue)\r\n            return Color.White\r\n        return Color.Black\r\n    }\r\n\r\n}\r\n\r\nCForklift.init()\r\n\r\nlet HEADING: number\r\nlet ASSIGN = [\"none\", \"groen\", \"blauw\", \"geel\", \"zwart\", \"rood\", \"wit\",\r\n                \"oranje\", \"cyaan\", \"magenta\", \"indigo\", \"violet\", \"paars\"]\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Forklift\"\r\n//% block.loc.nl=\"Heftruck\"\r\nnamespace CForklift {\r\n\r\n    export enum Lift {\r\n        //% block=\"up\"\r\n        //% block.loc.nl=\"omhoog\"\r\n        Up,\r\n        //% block=\"down\"\r\n        //% block.loc.nl=\"omlaag\"\r\n        Down\r\n    }\r\n\r\n    export function init() {\r\n        HEADING = input.compassHeading()\r\n        ColorSensor.init()\r\n        basic.showLeds(`\r\n            . . . . .\r\n            . . . . .\r\n            . . # . .\r\n            . . . . .\r\n            . . . . .\r\n            `)\r\n        basic.pause(500)\r\n        basic.showIcon(IconNames.SmallSquare)\r\n        basic.pause(500)\r\n        basic.showIcon(IconNames.Square)\r\n        basic.pause(500)\r\n        basic.clearScreen()\r\n        CForklift.lift(CForklift.Lift.Up)\r\n        basic.pause(500)\r\n        CForklift.lift(CForklift.Lift.Down)\r\n        basic.showIcon(IconNames.Yes)\r\n    }\r\n\r\n    //% block=\"is loaded\"\r\n    //% block.loc.nl=\"is geladen\"\r\n    export function isLoaded() : boolean {\r\n        pins.setPull(Nezha.Connector.J1, PinPullMode.PullUp)\r\n        return (pins.digitalReadPin(Nezha.Connector.J1) == 0)\r\n    }\r\n\r\n    //% block=\"move the lift %dir\"\r\n    //% block.loc.nl=\"beweeg de lift %dir\"\r\n    export function lift(dir: Lift) {\r\n        if (dir) { // down\r\n            for (let i = 320; i >= 0; i--) {\r\n                Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n                basic.pause(2)\r\n            }\r\n            Nezha.servoAngle( Nezha.Servo.S2, 350)\r\n            basic.pause(100)\r\n            Nezha.servoAngle( Nezha.Servo.S2, 360)\r\n        }\r\n        else { // up\r\n            Nezha.servoAngle( Nezha.Servo.S2, 350)\r\n            basic.pause(100)\r\n            Nezha.servoAngle( Nezha.Servo.S2, 340)\r\n            for (let i = 0; i <= 320; i++) {\r\n                Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n                basic.pause(2)\r\n            }\r\n        }\r\n    }\r\n\r\n    //% block=\"assign %dest to box %color\"\r\n    //% block.loc.nl=\"wijs %dest toe aan vak %color\"\r\n    export function assign(dest: string, color: Color) {\r\n        let ix: number = color\r\n        ASSIGN[ix] = dest\r\n    }\r\n}\r\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-forklift\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-mecanum\": \"github:CBurg-College/pxt-mecanum#fde56d8c97bd92d2e7600e8cdf3c245f626b405e\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1753468659348,"editorVersion":"8.0.11","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"/*\r\nFrom here to the 'pxt-soccer-player' specific code,\r\nthe code below is a composition and refactoring of:\r\n- the ElecFreaks 'pxt-nezha' library:\r\n  https://github.com/elecfreaks/pxt-nezha/blob/master/main.ts\r\n- the ElecFreaks 'pxt-PlanetX' library:\r\n  https://github.com/elecfreaks/pxt-PlanetX/blob/master/basic.ts\r\nBoth under MIT-license.\r\n*/\r\n\r\nnamespace Nezha {\r\n\r\n    export enum Connector {\r\n        //% block=\"J1\" \r\n        J1 = DigitalPin.P8,\r\n        //% block=\"J2\"\r\n        J2 = DigitalPin.P12,\r\n        //% block=\"J3\"\r\n        J3 = DigitalPin.P14,\r\n        //% block=\"J4\"\r\n        J4 = DigitalPin.P16\r\n    }\r\n\r\n    export enum Servo {\r\n        //% block=\"S1\" \r\n        S1,\r\n        //% block=\"S2\"\r\n        S2,\r\n        //% block=\"S3\" \r\n        S3,\r\n        //% block=\"S4\"\r\n        S4\r\n    }\r\n\r\n    export enum Motor {\r\n        //% block=\"M1\"\r\n        M1,\r\n        //% block=\"M2\"\r\n        M2,\r\n        //% block=\"M3\"\r\n        M3,\r\n        //% block=\"M4\"\r\n        M4\r\n    }\r\n\r\n    export function motorSpeed(motor: Motor, speed: number): void {\r\n\r\n        let iic_buffer = pins.createBuffer(4);\r\n\r\n        if (speed > 100) speed = 100\r\n        else\r\n            if (speed < -100) speed = -100\r\n\r\n        iic_buffer[0] = motor + 1\r\n        if (speed >= 0) {\r\n            iic_buffer[1] = 0x01; // forward\r\n            iic_buffer[2] = speed;\r\n        }\r\n        else {\r\n            iic_buffer[1] = 0x02; // reverse\r\n            iic_buffer[2] = -speed;\r\n        }\r\n        iic_buffer[3] = 0;\r\n\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, 360, 0, 180)\r\n        let iic_buffer = pins.createBuffer(4);\r\n        iic_buffer[0] = 0x10 + servo\r\n        iic_buffer[1] = angle;\r\n        iic_buffer[2] = 0;\r\n        iic_buffer[3] = 0;\r\n        pins.i2cWriteBuffer(0x10, iic_buffer);\r\n    }\r\n\r\n}\r\n\r\n/*\r\nGeneral color module\r\nUsed by ColorSensor\r\n*/\r\n\r\nenum Color {\r\n    //% block=\"none\"\r\n    //% block.loc.nl=\"geen\"\r\n    None,\r\n    //% block=\"green\"\r\n    //% block.loc.nl=\"groen\"\r\n    Green,\r\n    //% block=\"blue\"\r\n    //% block.loc.nl=\"blauw\"\r\n    Blue,\r\n    //% block=\"yellow\"\r\n    //% block.loc.nl=\"geel\"\r\n    Yellow,\r\n    //% block=\"black\"\r\n    //% block.loc.nl=\"zwart\"\r\n    Black,\r\n    //% block=\"red\"\r\n    //% block.loc.nl=\"rood\"\r\n    Red,\r\n    //% block=\"white\"\r\n    //% block.loc.nl=\"wit\"\r\n    White,\r\n    //% block=\"orange\"\r\n    //% block.loc.nl=\"oranje\"\r\n    Orange,\r\n    //% block=\"cyan\"\r\n    //% block.loc.nl=\"cyaan\"\r\n    Cyan,\r\n    //% block=\"magenta\"\r\n    //% block.loc.nl=\"magenta\"\r\n    Magenta,\r\n    //% block=\"indigo\"\r\n    //% block.loc.nl=\"indigo\"\r\n    Indigo,\r\n    //% block=\"violet\"\r\n    //% block.loc.nl=\"violet\"\r\n    Violet,\r\n    //% block=\"purple\"\r\n    //% block.loc.nl=\"paars\"\r\n    Purple\r\n}\r\n\r\nfunction rgb(color: Color): number {\r\n    let val = 0\r\n    switch (color) {\r\n        case Color.Green: val = 0x00FF00; break;\r\n        case Color.Blue: val = 0x0000FF; break;\r\n        case Color.Yellow: val = 0xFFFF00; break;\r\n        case Color.Black: val = 0x000000; break;\r\n        case Color.Red: val = 0xFF0000; break;\r\n        case Color.White: val = 0xFFFFFF; break;\r\n        case Color.Orange: val = 0xFFA500; break;\r\n        case Color.Cyan: val = 0x00FFFF; break;\r\n        case Color.Magenta: val = 0xFF00FF; break;\r\n        case Color.Indigo: val = 0x4b0082; break;\r\n        case Color.Violet: val = 0x8a2be2; break;\r\n        case Color.Purple: val = 0xFF00FF; break;\r\n    }\r\n    return val\r\n}\r\n\r\nfunction pack(red: number, green: number, blue: number): number {\r\n    let rgb = ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF)\r\n    return rgb;\r\n}\r\n\r\nfunction rgb2hsl(color_r: number, color_g: number, color_b: number): number {\r\n    let Hue = 0\r\n    let R = color_r * 100 / 255;\r\n    let G = color_g * 100 / 255;\r\n    let B = color_b * 100 / 255;\r\n    let maxVal = Math.max(R, Math.max(G, B))\r\n    let minVal = Math.min(R, Math.min(G, B))\r\n    let Delta = maxVal - minVal;\r\n\r\n    if (Delta < 0) {\r\n        Hue = 0;\r\n    }\r\n    else if (maxVal == R && G >= B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta)) / 100;\r\n    }\r\n    else if (maxVal == R && G < B) {\r\n        Hue = (60 * ((G - B) * 100 / Delta) + 360 * 100) / 100;\r\n    }\r\n    else if (maxVal == G) {\r\n        Hue = (60 * ((B - R) * 100 / Delta) + 120 * 100) / 100;\r\n    }\r\n    else if (maxVal == B) {\r\n        Hue = (60 * ((R - G) * 100 / Delta) + 240 * 100) / 100;\r\n    }\r\n    return Hue\r\n}\r\n\r\nfunction hsl2rgb(h: number, s: number, l: number): number {\r\n    h = Math.round(h);\r\n    s = Math.round(s);\r\n    l = Math.round(l);\r\n\r\n    h = h % 360;\r\n    s = Math.clamp(0, 99, s);\r\n    l = Math.clamp(0, 99, l);\r\n    let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\r\n    let h1 = Math.idiv(h, 60);//[0,6]\r\n    let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\r\n    let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\r\n    let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\r\n    let r$: number;\r\n    let g$: number;\r\n    let b$: number;\r\n    if (h1 == 0) {\r\n        r$ = c;\r\n        g$ = x;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 1) {\r\n        r$ = x;\r\n        g$ = c;\r\n        b$ = 0;\r\n    }\r\n    else if (h1 == 2) {\r\n        r$ = 0;\r\n        g$ = c;\r\n        b$ = x;\r\n    }\r\n    else if (h1 == 3) {\r\n        r$ = 0;\r\n        g$ = x;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 4) {\r\n        r$ = x;\r\n        g$ = 0;\r\n        b$ = c;\r\n    }\r\n    else if (h1 == 5) {\r\n        r$ = c;\r\n        g$ = 0;\r\n        b$ = x;\r\n    }\r\n    let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\r\n    let r = r$ + m;\r\n    let g = g$ + m;\r\n    let b = b$ + m;\r\n    let rgb = ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF)\r\n    return rgb;\r\n}\r\n\r\n/*\r\nPlanetX color sensor\r\n*/\r\n\r\nnamespace ColorSensor {\r\n\r\n    const APDS9960_ADDR = 0x39\r\n    const APDS9960_ENABLE = 0x80\r\n    const APDS9960_ATIME = 0x81\r\n    const APDS9960_CONTROL = 0x8F\r\n    const APDS9960_STATUS = 0x93\r\n    const APDS9960_CDATAL = 0x94\r\n    const APDS9960_CDATAH = 0x95\r\n    const APDS9960_RDATAL = 0x96\r\n    const APDS9960_RDATAH = 0x97\r\n    const APDS9960_GDATAL = 0x98\r\n    const APDS9960_GDATAH = 0x99\r\n    const APDS9960_BDATAL = 0x9A\r\n    const APDS9960_BDATAH = 0x9B\r\n    const APDS9960_GCONF4 = 0xAB\r\n    const APDS9960_AICLEAR = 0xE7\r\n\r\n    let color_first_init = false\r\n    let color_new_init = false\r\n\r\n    function i2cwrite_color(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread_color(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    export function init() {\r\n\r\n        // init module\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ATIME, 252)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_CONTROL, 0x03)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_GCONF4, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_AICLEAR, 0x00)\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, 0x01)\r\n        color_first_init = true\r\n\r\n        // set to color mode\r\n        let tmp = i2cread_color(APDS9960_ADDR, APDS9960_ENABLE) | 0x2;\r\n        i2cwrite_color(APDS9960_ADDR, APDS9960_ENABLE, tmp);\r\n    }\r\n\r\n    export function readColor(): Color {\r\n        let buf = pins.createBuffer(2)\r\n        let c = 0\r\n        let r = 0\r\n        let g = 0\r\n        let b = 0\r\n        let temp_c = 0\r\n        let temp_r = 0\r\n        let temp_g = 0\r\n        let temp_b = 0\r\n        let temp = 0\r\n\r\n        if (color_new_init == false && color_first_init == false) {\r\n            let i = 0;\r\n            while (i++ < 20) {\r\n                buf[0] = 0x81\r\n                buf[1] = 0xCA\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                buf[0] = 0x80\r\n                buf[1] = 0x17\r\n                pins.i2cWriteBuffer(0x43, buf)\r\n                basic.pause(50);\r\n\r\n                if ((i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256) != 0) {\r\n                    color_new_init = true\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (color_new_init == true) {\r\n            basic.pause(100);\r\n            c = i2cread_color(0x43, 0xA6) + i2cread_color(0x43, 0xA7) * 256;\r\n            r = i2cread_color(0x43, 0xA0) + i2cread_color(0x43, 0xA1) * 256;\r\n            g = i2cread_color(0x43, 0xA2) + i2cread_color(0x43, 0xA3) * 256;\r\n            b = i2cread_color(0x43, 0xA4) + i2cread_color(0x43, 0xA5) * 256;\r\n\r\n            r *= 1.3 * 0.47 * 0.83\r\n            g *= 0.69 * 0.56 * 0.83\r\n            b *= 0.80 * 0.415 * 0.83\r\n            c *= 0.3\r\n\r\n            if (r > b && r > g) {\r\n                b *= 1.18;\r\n                g *= 0.95\r\n            }\r\n\r\n            temp_c = c\r\n            temp_r = r\r\n            temp_g = g\r\n            temp_b = b\r\n\r\n            r = Math.min(r, 4095.9356)\r\n            g = Math.min(g, 4095.9356)\r\n            b = Math.min(b, 4095.9356)\r\n            c = Math.min(c, 4095.9356)\r\n\r\n            if (temp_b < temp_g) {\r\n                temp = temp_b\r\n                temp_b = temp_g\r\n                temp_g = temp\r\n            }\r\n        }\r\n        else {\r\n            if (color_first_init == false)\r\n                init()\r\n            let tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            while (!tmp) {\r\n                basic.pause(5);\r\n                tmp = i2cread_color(APDS9960_ADDR, APDS9960_STATUS) & 0x1;\r\n            }\r\n            c = i2cread_color(APDS9960_ADDR, APDS9960_CDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_CDATAH) * 256;\r\n            r = i2cread_color(APDS9960_ADDR, APDS9960_RDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_RDATAH) * 256;\r\n            g = i2cread_color(APDS9960_ADDR, APDS9960_GDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_GDATAH) * 256;\r\n            b = i2cread_color(APDS9960_ADDR, APDS9960_BDATAL) + i2cread_color(APDS9960_ADDR, APDS9960_BDATAH) * 256;\r\n        }\r\n\r\n        // map to rgb based on clear channel\r\n        let avg = c / 3;\r\n        r = r * 255 / avg;\r\n        g = g * 255 / avg;\r\n        b = b * 255 / avg;\r\n\r\n        // translate rgb to hue\r\n        let hue = rgb2hsl(r, g, b)\r\n        if (color_new_init == true && hue >= 180 && hue <= 201 && temp_c >= 6000 && (temp_b - temp_g) < 1000 || (temp_r > 4096 && temp_g > 4096 && temp_b > 4096)) {\r\n            temp_c = Math.map(temp_c, 0, 15000, 0, 13000);\r\n            hue = 180 + (13000 - temp_c) / 1000.0;\r\n        }\r\n\r\n        // translate hue to color\r\n        if (hue > 330 || hue < 20)\r\n            return Color.Red\r\n        if (hue > 120 && 180 > hue)\r\n            return Color.Green\r\n        if (hue > 210 && 270 > hue)\r\n            return Color.Blue\r\n        if (hue > 190 && 210 > hue)\r\n            return Color.Cyan\r\n        if (hue > 260 && 330 > hue)\r\n            return Color.Magenta\r\n        if (hue > 30 && 120 > hue)\r\n            return Color.Yellow\r\n        if (hue >= 180 && 190 > hue)\r\n            return Color.White\r\n        return Color.Black\r\n    }\r\n\r\n}\r\n\r\nCForklift.init()\r\n\r\nlet HEADING: number\r\nlet ASSIGN = [\"none\", \"groen\", \"blauw\", \"geel\", \"zwart\", \"rood\", \"wit\",\r\n                \"oranje\", \"cyaan\", \"magenta\", \"indigo\", \"violet\", \"paars\"]\r\n\r\ntype routeHandler = () => void\r\n\r\nlet RouteGreenBringA: routeHandler\r\nlet RouteGreenStartA: routeHandler\r\nlet RouteBlueBringA: routeHandler\r\nlet RouteBlueStartA: routeHandler\r\nlet RouteYellowBringA: routeHandler\r\nlet RouteYellowStartA: routeHandler\r\n\r\nlet RouteGreenBringB: routeHandler\r\nlet RouteGreenStartB: routeHandler\r\nlet RouteBlueBringB: routeHandler\r\nlet RouteBlueStartB: routeHandler\r\nlet RouteYellowBringB: routeHandler\r\nlet RouteYellowStartB: routeHandler\r\n\r\nlet RouteHomeToStart: routeHandler\r\nlet RouteStartToHome: routeHandler\r\n\r\n\r\n//% color=\"#00CC00\" icon=\"\\uf1f9\"\r\n//% block=\"Forklift\"\r\n//% block.loc.nl=\"Heftruck\"\r\nnamespace CForklift {\r\n\r\n    export enum Lift {\r\n        //% block=\"up\"\r\n        //% block.loc.nl=\"omhoog\"\r\n        Up,\r\n        //% block=\"down\"\r\n        //% block.loc.nl=\"omlaag\"\r\n        Down\r\n    }\r\n\r\n    export enum Turn {\r\n        //% block=\"quarter turn to the left\"\r\n        //% block.loc.nl=\"kwartslag naar links\"\r\n        QuarterLeft,\r\n        //% block=\"quarter turn to the right\"\r\n        //% block.loc.nl=\"kwartslag naar rechts\"\r\n        QuarterRight,\r\n        //% block=\"half turn\"\r\n        //% block.loc.nl=\"halve draai\"\r\n        Half\r\n    }\r\n\r\n    export enum Direction {\r\n        //% block=\"to the left\"\r\n        //% block.loc.nl=\"naar links\"\r\n        Left,\r\n        //% block=\"to the right\"\r\n        //% block.loc.nl=\"naar rechts\"\r\n        Right\r\n    }\r\n\r\n    export function init() {\r\n        HEADING = input.compassHeading()\r\n        ColorSensor.init()\r\n        basic.showLeds(`\r\n            . . . . .\r\n            . . . . .\r\n            . . # . .\r\n            . . . . .\r\n            . . . . .\r\n            `)\r\n        basic.pause(500)\r\n        basic.showIcon(IconNames.SmallSquare)\r\n        basic.pause(500)\r\n        basic.showIcon(IconNames.Square)\r\n        basic.pause(500)\r\n        basic.clearScreen()\r\n        CForklift.lift(CForklift.Lift.Up)\r\n        basic.pause(500)\r\n        CForklift.lift(CForklift.Lift.Down)\r\n        basic.showIcon(IconNames.Yes)\r\n    }\r\n\r\n    //% block=\"move to %dir\"\r\n\r\n    //% block=\"make a %turn\"\r\n    //% block.loc.nl=\"maak een %turn\"\r\n    export function rotate(turn: Turn) {\r\n        switch (turn) {\r\n            case Turn.QuarterLeft: break;\r\n            case Turn.QuarterRight: break;\r\n            case Turn.Half: break;\r\n        }\r\n    }\r\n\r\n    //% block=\"is loaded\"\r\n    //% block.loc.nl=\"is geladen\"\r\n    export function isLoaded(): boolean {\r\n        pins.setPull(Nezha.Connector.J1, PinPullMode.PullUp)\r\n        return (pins.digitalReadPin(Nezha.Connector.J1) == 0)\r\n    }\r\n\r\n    //% block=\"unloading\"\r\n    //% block.loc.nl=\"lossen\"\r\n    export function unloading() {\r\n    }\r\n\r\n    //% block=\"loading\"\r\n    //% block.loc.nl=\"laden\"\r\n    export function loading() {\r\n    }\r\n\r\n    //% block=\"move the lift %dir\"\r\n    //% block.loc.nl=\"beweeg de lift %dir\"\r\n    export function lift(dir: Lift) {\r\n        if (dir) { // down\r\n            for (let i = 320; i >= 0; i--) {\r\n                Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n                basic.pause(2)\r\n            }\r\n            Nezha.servoAngle( Nezha.Servo.S2, 350)\r\n            basic.pause(100)\r\n            Nezha.servoAngle( Nezha.Servo.S2, 360)\r\n        }\r\n        else { // up\r\n            Nezha.servoAngle( Nezha.Servo.S2, 350)\r\n            basic.pause(100)\r\n            Nezha.servoAngle( Nezha.Servo.S2, 340)\r\n            for (let i = 0; i <= 320; i++) {\r\n                Nezha.servoAngle( Nezha.Servo.S1, 360 - i)\r\n                basic.pause(2)\r\n            }\r\n        }\r\n    }\r\n\r\n    //% block=\"assign %dest to box %color\"\r\n    //% block.loc.nl=\"wijs %dest toe aan vak %color\"\r\n    export function assign(dest: string, color: Color) {\r\n        let ix: number = color\r\n        ASSIGN[ix] = dest\r\n    }\r\n\r\n    //% subcategory=\"Route\"\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"bring to green A\"\r\n    //% block.locx.nl=\"breng naar groen A\"\r\n    export function goRouteGreenBringA(programmableCode: () => void): void {\r\n        RouteGreenBringA = programmableCode;\r\n    }\r\n\r\n    //% subcategory=\"Route\"\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"bring to green B\"\r\n    //% block.locx.nl=\"breng naar groen B\"\r\n    export function goRouteGreenBringB(programmableCode: () => void): void {\r\n        RouteGreenBringB = programmableCode;\r\n    }\r\n\r\n    //% subcategory=\"Route\"\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"bring to blue A\"\r\n    //% block.locx.nl=\"breng naar blauw A\"\r\n    export function goRouteBlueBringA(programmableCode: () => void): void {\r\n        RouteBlueBringA = programmableCode;\r\n    }\r\n\r\n    //% subcategory=\"Route\"\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"bring to blue B\"\r\n    //% block.locx.nl=\"breng naar blauw B\"\r\n    export function goRouteBlueBringB(programmableCode: () => void): void {\r\n        RouteBlueBringB = programmableCode;\r\n    }\r\n\r\n    //% subcategory=\"Route\"\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"bring to yellow A\"\r\n    //% block.locx.nl=\"breng naar geel A\"\r\n    export function goRouteYellowBringA(programmableCode: () => void): void {\r\n        RouteGreenBringA = programmableCode;\r\n    }\r\n\r\n    //% subcategory=\"Route\"\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"bring to yellow B\"\r\n    //% block.locx.nl=\"breng naar geel B\"\r\n    export function goRouteYellowBringB(programmableCode: () => void): void {\r\n        RouteYellowBringB = programmableCode;\r\n    }\r\n\r\n    //% subcategory=\"Route\"\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"from home to start\"\r\n    //% block.locx.nl=\"van thuisbasis naar start\"\r\n    export function goRouteHomeToStart(programmableCode: () => void): void {\r\n        RouteHomeToStart = programmableCode;\r\n    }\r\n\r\n    //% subcategory=\"Route\"\r\n    //% color=\"#FFCC00\"\r\n    //% block=\"from start to home\"\r\n    //% block.locx.nl=\"van start naar thuisbasis\"\r\n    export function goStartToHome(programmableCode: () => void): void {\r\n        RouteStartToHome = programmableCode;\r\n    }\r\n}\r\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-forklift\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-mecanum\": \"github:CBurg-College/pxt-mecanum#fde56d8c97bd92d2e7600e8cdf3c245f626b405e\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1753469309947}